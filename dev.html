<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spatial Memory Trainer</title>

<style>
  :root{
    --bg:#0b1020;
    --panel:#111a33;
    --arena:#101a35;
    --text:#eef;
    --muted:#b7c0ee;

    --flash1:#1f2f66;   /* brighter */
    --flash2:#0d1633;   /* darker */
  }

  body{
    margin:0;
    background: radial-gradient(1000px 700px at 50% 10%, #1a2a5a, var(--bg));
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    display:grid;
    grid-template-rows:auto 1fr;
    height:100vh;
  }

  header{
    padding:10px 14px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    background: rgba(17,26,51,0.85);
    border-bottom: 1px solid rgba(255,255,255,0.10);
    gap:12px;
    flex-wrap:wrap;
  }

  #status{ color:var(--muted); font-size:14px; }
  #level { font-size:14px; }

  button{
    padding:7px 12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.10);
    color:var(--text);
    cursor:pointer;
  }
  button:hover{ background: rgba(255,255,255,0.16); }

  #gameWrap{ display:grid; place-items:center; padding:12px; }

  #game{
    position:relative;
    width:min(900px, 96vw);
    height:min(600px, 72vh);
    background: rgba(16,26,53,0.75);
    border:1px solid rgba(255,255,255,0.12);
    border-radius:18px;
    overflow:hidden;
    box-shadow: 0 20px 70px rgba(0,0,0,0.35);
    transition: background 120ms linear;
  }

  /* flash/flicker states */
  #game.flashA{ background: rgba(31,47,102,0.85); }
  #game.flashB{ background: rgba(13,22,51,0.90); }

  /* Central arena (invisible boundary for placement) */
  #arena{
    position:absolute;
    left:15%;
    top:20%;
    width:70%;
    height:60%;
    pointer-events:none;
  }

  .circle{
    position:absolute;
    border-radius:50%;
    border:2px solid rgba(255,255,255,0.18);
    box-shadow: 0 10px 25px rgba(0,0,0,0.25);
    opacity:0;
    transform: scale(0.96);
    transition: opacity 160ms ease, transform 160ms ease, left 160ms ease, top 160ms ease, width 160ms ease, height 160ms ease;
    -webkit-tap-highlight-color: transparent;
    user-select:none;
    touch-action: manipulation;
  }
  .circle.visible{ opacity:1; transform: scale(1); }
  .circle.wrong{
    border-color: rgba(255,120,120,0.95);
    box-shadow: 0 0 0 4px rgba(255,120,120,0.18), 0 10px 25px rgba(0,0,0,0.25);
  }
</style>
</head>

<body>

<header>
  <div style="display:flex; gap:10px; align-items:center;">
    <button id="startBtn">Start / Reset</button>
    <div id="level">N = 2</div>
  </div>
  <div id="status">Press Start once. Then it runs continuously.</div>
</header>

<div id="gameWrap">
  <div id="game">
    <div id="arena"></div>
  </div>
</div>

<script>
(() => {
  const game   = document.getElementById("game");
  const arena  = document.getElementById("arena");
  const startBtn = document.getElementById("startBtn");
  const statusEl = document.getElementById("status");
  const levelEl  = document.getElementById("level");

  // ---------- Tuning knobs ----------
  const MIN_N = 2;
  const MAX_N = 30;

  const SHOW_MS = 650;
  const GAP_MS  = 250;

  const SHOW_RADIUS_MIN = 34;
  const SHOW_RADIUS_MAX = 54;

  const RECALL_RADIUS   = 22;    // fixed small size for recall
  const PADDING_BETWEEN = 12;    // non-overlap margin

  const BETWEEN_ROUNDS_MS = 900; // pause after success/fail

  // NEW: pre-round cue
  const PRE_ROUND_DELAY_MS = 650;     // delay before next round begins
  const FLICKER_COUNT = 2;            // number of flickers
  const FLICKER_STEP_MS = 90;         // each flicker step duration

  // ---------- Audio ----------
  let audioCtx = null;
  function ensureAudio() {
    audioCtx ??= new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    return audioCtx;
  }
  function tone(freq, ms=120) {
    const ctx = ensureAudio();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "sine";
    o.frequency.value = freq;

    const now = ctx.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.16, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + ms/1000);

    o.connect(g); g.connect(ctx.destination);
    o.start(now);
    o.stop(now + ms/1000 + 0.03);
  }

  // ---------- Helpers ----------
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));
  const rand  = (a,b) => Math.random()*(b-a)+a;
  const clamp = (v,lo,hi) => Math.max(lo, Math.min(hi, v));
  const dist  = (a,b) => Math.hypot(a.cx-b.cx, a.cy-b.cy);

  function setStatus(s){ statusEl.textContent = s; }
  function setLevel(){ levelEl.textContent = `N = ${N}`; }

  // NEW: flicker cue before round begins
  async function preRoundCue(token) {
  // Quick flicker (A/B) + small delay.
  // Important: always clean up flash classes even if a reset cancels the round.
  try {
    for (let i = 0; i < FLICKER_COUNT; i++) {
      if (token !== runToken) return;

      game.classList.add("flashA");
      await sleep(FLICKER_STEP_MS);

      // If we were cancelled while flashA is on, ensure we turn it off before returning.
      game.classList.remove("flashA");
      if (token !== runToken) return;

      game.classList.add("flashB");
      await sleep(FLICKER_STEP_MS);

      game.classList.remove("flashB");
    }

    if (token !== runToken) return;
    await sleep(PRE_ROUND_DELAY_MS);
  } finally {
    game.classList.remove("flashA");
    game.classList.remove("flashB");
  }
}

  // ---------- Game state ----------
  let N = 2;
  let phase = "idle"; // idle | showing | recall | transition
  let expectedIndex = 0;

  let circles = []; // each: { cx, cy, rShow, hue, freq, el, index }

  let runToken = 0; // cancel in-progress loops on reset

  function clearBoard() {
    circles.forEach(c => c.el?.remove());
    circles = [];
    expectedIndex = 0;
  }

  function arenaRectInGameCoords() {
    const g = game.getBoundingClientRect();
    const a = arena.getBoundingClientRect();
    return {
      left: a.left - g.left,
      top:  a.top  - g.top,
      width: a.width,
      height: a.height
    };
  }

  function makeCircleElement(c) {
    const el = document.createElement("div");
    el.className="circle";
    el.style.background =
      `radial-gradient(circle at 30% 30%, rgba(255,255,255,0.45), hsl(${c.hue} 85% 60%))`;

    el.addEventListener("pointerdown", (e) => {
      if (phase !== "recall") return;
      handleClick(c);
      e.preventDefault();
    });

    game.appendChild(el);
    c.el = el;
  }

  function setCircleGeometry(c, r) {
    c.el.style.width  = `${2*r}px`;
    c.el.style.height = `${2*r}px`;
    c.el.style.left   = `${c.cx - r}px`;
    c.el.style.top    = `${c.cy - r}px`;
  }

  function nonOverlappingPlacement(n) {
    const ar = arenaRectInGameCoords();
    const placed = [];

    for (let i=0; i<n; i++) {
      let ok = false;

      for (let tries=0; tries<250; tries++) {
        const rShow = rand(SHOW_RADIUS_MIN, SHOW_RADIUS_MAX);
        const cx = rand(ar.left + rShow, ar.left + ar.width  - rShow);
        const cy = rand(ar.top  + rShow, ar.top  + ar.height - rShow);
        const candidate = { cx, cy, rShow };

        const tooClose = placed.some(p => dist(candidate, p) < (candidate.rShow + p.rShow + PADDING_BETWEEN));
        if (!tooClose) {
          ok = true;
          const hue = Math.floor(rand(0,360));
          const freq = 220 + (hue/359)*660;
          placed.push({ cx, cy, rShow, hue, freq });
          break;
        }
      }

      // fallback if crowded
      if (!ok) {
        const rShow = rand(SHOW_RADIUS_MIN, SHOW_RADIUS_MAX);
        const cx = rand(ar.left + rShow, ar.left + ar.width  - rShow);
        const cy = rand(ar.top  + rShow, ar.top  + ar.height - rShow);
        const hue = Math.floor(rand(0,360));
        const freq = 220 + (hue/359)*660;
        placed.push({ cx, cy, rShow, hue, freq });
      }
    }

    return placed;
  }

  async function runRound(token) {
    phase = "transition";
    clearBoard();
    setLevel();

    // NEW: little cue/flicker before round starts
    setStatus("Get ready…");
    await preRoundCue(token);
    if (token !== runToken) return;

    phase = "showing";
    setStatus(`Watch the sequence… (${N})`);

    // Create circles (hidden)
    circles = nonOverlappingPlacement(N).map((c, i) => ({ ...c, index:i, el:null }));
    circles.forEach(c => {
      makeCircleElement(c);
      setCircleGeometry(c, c.rShow);
      c.el.classList.remove("wrong");
      c.el.classList.remove("visible");
    });

    // Show them one-at-a-time
    for (let i=0; i<N; i++) {
      if (token !== runToken) return;
      const c = circles[i];
      c.el.classList.add("visible");
      tone(c.freq, Math.min(180, Math.floor(SHOW_MS*0.28)));
      await sleep(SHOW_MS);
      c.el.classList.remove("visible");
      await sleep(GAP_MS);
    }

    // Recall phase: show all at fixed small size
    phase = "recall";
    expectedIndex = 0;
    circles.forEach(c => {
      setCircleGeometry(c, RECALL_RADIUS);
      c.el.classList.add("visible");
    });

    setStatus(`Your turn: click in order (1 → ${N}).`);
  }

  function handleClick(circleObj) {
    const i = circleObj.index;

    if (i === expectedIndex) {
      tone(660, 80);

      // erase immediately
      circleObj.el.remove();

      expectedIndex++;
      if (expectedIndex >= N) onSuccess();
      else setStatus(`Good! Next: ${expectedIndex + 1} of ${N}.`);
    } else {
      tone(180, 160);
      circleObj.el.classList.add("wrong");
      setTimeout(() => circleObj.el?.classList.remove("wrong"), 260);
      onFailure();
    }
  }

  async function onSuccess() {
    phase = "transition";
    setStatus(`✅ Success! Next round…`);
    N = clamp(N + 1, MIN_N, MAX_N);
    await sleep(BETWEEN_ROUNDS_MS);
    if (phase !== "transition") return;
    await runRound(runToken);
  }

  async function onFailure() {
    phase = "transition";
    setStatus(`❌ Wrong order. Adjusting…`);
    N = clamp(N - 1, MIN_N, MAX_N);
    await sleep(BETWEEN_ROUNDS_MS);
    if (phase !== "transition") return;
    await runRound(runToken);
  }

  startBtn.addEventListener("click", async () => {
    ensureAudio();     // unlock on gesture
    runToken++;        // cancel any existing loops
    phase = "idle";
    N = 2;
    setLevel();
    clearBoard();
    // In case a reset happened mid-flicker, force-clear any flash state.
    game.classList.remove("flashA");
    game.classList.remove("flashB");
    setStatus("Starting…");
    await sleep(120);
    await runRound(runToken);
  });

})();
</script>

</body>
</html>