<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Spatial Memory Trainer</title>

<style>
  :root{
    --bg:#0b1020;
    --panel:#111a33;
    --arena:#101a35;
    --text:#eef;
    --muted:#b7c0ee;

    --flash1:#1f2f66;
    --flash2:#0d1633;

    /* chosen by dropdown */
    --bgA:#1a2a5a;
    --bgB:#0b1020;

    --gameA: rgba(16,26,53,0.78);
    --gameB: rgba(16,26,53,0.78);
  }

  html, body{ height:100%; width:100%; overflow:hidden; }
  body{
    margin:0;
    background: radial-gradient(1000px 700px at 50% 10%, var(--bgA), var(--bgB));
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    display:grid;
    grid-template-rows:auto 1fr;
    height:100dvh;
    position:fixed;
    inset:0;
    overflow:hidden;
  }

  header{
    padding:10px 14px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    background: rgba(17,26,51,0.88);
    border-bottom: 1px solid rgba(255,255,255,0.10);
    gap:12px;
    flex-wrap:wrap;
  }

  #status{ color:var(--muted); font-size:14px; }
  #level { font-size:14px; }
  #controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

  button{
    padding:7px 12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.10);
    color:var(--text);
    cursor:pointer;
  }
  button:hover{ background: rgba(255,255,255,0.16); }

  select{
    padding:7px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.10);
    color:var(--text);
    outline:none;
  }
  option{ color:#111; }

  #closeBtn{
    font-size:16px;
    line-height:1;
    padding:7px 12px;
  }

  #gameWrap{
    display:grid;
    place-items:center;
    padding:12px;
    padding-bottom: calc(12px + env(safe-area-inset-bottom));
  }

  #game{
    touch-action: none;
    position:relative;
    width:min(900px, 96vw);
    height:min(600px, 72vh);
    background: radial-gradient(900px 650px at 50% 35%, var(--gameA), var(--gameB));
    border:1px solid rgba(255,255,255,0.12);
    border-radius:18px;
    overflow:hidden;
    box-shadow: 0 20px 70px rgba(0,0,0,0.35);
    transition: background 160ms ease, box-shadow 220ms ease;
  }

  #game.flashA{ background: rgba(31,47,102,0.88); }
  #game.flashB{ background: rgba(13,22,51,0.92); }

  /* Gold success/failure transition */
  #game.goldA{
    background: radial-gradient(900px 650px at 50% 35%,
      rgba(255,236,170,0.88),
      rgba(255,196,80,0.58),
      rgba(16,26,53,0.92));
  }
  #game.goldB{
    background: radial-gradient(900px 650px at 50% 35%,
      rgba(255,250,210,0.95),
      rgba(255,215,120,0.66),
      rgba(16,26,53,0.94));
  }
  #game.goldGlow{
    box-shadow:
      0 0 0 3px rgba(255,215,120,0.35),
      0 0 45px rgba(255,215,120,0.95),
      0 0 110px rgba(255,215,120,0.60),
      0 0 180px rgba(255,215,120,0.28),
      0 20px 70px rgba(0,0,0,0.35);
  }

  /* Central arena (invisible boundary for placement) */
  #arena{
    position:absolute;
    left:15%;
    top:20%;
    width:70%;
    height:60%;
    pointer-events:none;
  }

  .circle{
    position:absolute;
    border-radius:50%;
    border:2px solid rgba(255,255,255,0.22);
    box-shadow: 0 10px 25px rgba(0,0,0,0.25);
    opacity:0;
    transform: scale(0.96);
    transition: opacity 160ms ease, transform 160ms ease, left 160ms ease, top 160ms ease, width 160ms ease, height 160ms ease;
    -webkit-tap-highlight-color: transparent;
    user-select:none;
    touch-action: manipulation;
    overscroll-behavior: none;
  }
  .circle.visible{ opacity:1; transform: scale(1); }

  /* Calmer encoding: keep previously shown circles lightly visible */
  .circle.dim{
    opacity: 0.35 !important;
    transform: scale(0.985);
    filter: saturate(0.95);
  }
  .circle.active{
    opacity: 1 !important;
    transform: scale(1.03);
    border-color: rgba(255,255,255,0.34);
    box-shadow:
      0 0 0 3px rgba(255,255,255,0.14),
      0 10px 25px rgba(0,0,0,0.25);
  }

  .circle.wrong{
    border-color: rgba(255,120,120,0.95);
    box-shadow: 0 0 0 4px rgba(255,120,120,0.18), 0 10px 25px rgba(0,0,0,0.25);
  }
  .circle.glow{
    border-color: rgba(255,215,120,0.98);
    box-shadow:
      0 0 0 4px rgba(255,215,120,0.28),
      0 0 22px rgba(255,215,120,0.90),
      0 0 46px rgba(255,215,120,0.60),
      0 10px 25px rgba(0,0,0,0.25);
    transition: box-shadow 220ms ease, border-color 220ms ease;
  }


  /* Lines layer (sequence connections) */
  #linesLayer{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    pointer-events:none;
    overflow:visible;
  }
  #linesLayer line{
    stroke: rgba(255,255,255,0.55);
    stroke-width: 2.25;
    stroke-linecap: round;
  }

  /* End screen */
  #overlay{
    position:absolute;
    inset:0;
    background: rgba(0,0,0,0.55);
    display:none;
    align-items:center;
    justify-content:center;
    padding:18px;
  }
  #overlay.show{ display:flex; }
  #panel{
    width:min(520px, 92vw);
    background: rgba(17,26,51,0.94);
    border:1px solid rgba(255,255,255,0.14);
    border-radius:18px;
    box-shadow: 0 25px 90px rgba(0,0,0,0.55);
    padding:18px 18px 14px;
  }
  #panel h2{
    margin:0 0 8px;
    font-size:20px;
    font-weight:800;
    letter-spacing:0.2px;
  }
  #score{
    margin:10px 0 14px;
    font-size:34px;
    font-weight:900;
  }
  #panel p{
    margin:0 0 14px;
    color:var(--muted);
    line-height:1.35;
  }
  #panel .row{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:flex-end;
  }

  /* --- v15: Primary Play button --- */
  button.primary{
    padding:10px 18px;
    font-size:16px;
    font-weight:700;
    letter-spacing:0.2px;
    border:1px solid rgba(255,255,255,0.28);
    background: rgba(255,255,255,0.12);
    box-shadow: 0 0 18px rgba(255,215,128,0.18);
    position:relative;
  }
  @keyframes softPulse{
    0%,100%{ box-shadow: 0 0 18px rgba(255,215,128,0.16); }
    50%{ box-shadow: 0 0 26px rgba(255,215,128,0.24); }
  }
  button.primary:not(:disabled){
    animation: softPulse 2.6s ease-in-out infinite;
  }

  /* --- v15: Background swatch strip --- */
  .bg-palette-wrap{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }
  .bg-label{
    color:var(--muted);
    font-size:14px;
  }
  .bg-palette{
    display:flex;
    gap:8px;
    align-items:center;
    padding:4px 6px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.06);
    max-width:min(420px, 74vw);
    overflow-x:auto;
    -webkit-overflow-scrolling: touch;
  }
  .bg-swatch{
    width:26px;
    height:26px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.22);
    box-shadow: inset 0 0 0 1px rgba(0,0,0,0.18);
    flex:0 0 auto;
    cursor:pointer;
    position:relative;
  }
  .bg-swatch[aria-selected="true"]{
    outline:2px solid rgba(255,255,255,0.85);
    outline-offset:2px;
  }


  /* --- v19: Tuning controls (Timing + Size) --- */
  .tune-wrap{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }
  .tune{
    display:flex;
    gap:8px;
    align-items:center;
    padding:4px 6px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.06);
  }
  .tune-label{
    color:var(--muted);
    font-size:14px;
    margin-right:2px;
  }
  .tune-btn{
    width:30px;
    height:30px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.18);
    background: rgba(0,0,0,0.10);
    color:var(--text);
    font-weight:700;
    line-height:1;
  }
  .tune-btn:active{ transform: scale(0.98); }
  .dots{
    display:flex;
    gap:4px;
    align-items:center;
    padding:0 2px;
  }
  .dot{
    width:7px;
    height:7px;
    border-radius:50%;
    background: rgba(255,255,255,0.18);
    box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25);
  }
  .dot.on{ background: rgba(255,255,255,0.80); }


  /* --- Miss allowance (3 dots) --- */
  .missBar{
    display:flex;
    gap:6px;
    align-items:center;
    padding:6px 10px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,0.14);
    background: rgba(255,255,255,0.06);
  }
  .missDot{
    width:10px; height:10px;
    border-radius:50%;
    background: rgba(255,255,255,0.85);
    box-shadow: 0 0 0 1px rgba(0,0,0,0.18) inset;
    opacity: 0.95;
  }
  .missDot.used{
    background: rgba(255,120,120,0.75);
    opacity: 0.55;
  }


  /* Photo background swatch button */
  .bgSwatch.photo{
    display:none;
    align-items:center;
    justify-content:center;
    font-size:16px;
    line-height:1;
    border-style:dashed;
    border-width:1px;
  }
  .bgSwatch.photo::after{ content:""; }
  .photoBgActive .bg-palette-wrap{ backdrop-filter: blur(2px); }


  /* Photo background: avoid cropping faces by using CONTAIN.
     Add a soft blurred "fill" behind so letterboxing looks good. */
  #playPanel.photoBgActive{
    position: relative;
    overflow: hidden;
    background-image: var(--photoUrl);
    background-size: contain;
    background-position: center center;
    background-repeat: no-repeat;
  }
  #playPanel.photoBgActive::before{
    content:"";
    position:absolute;
    inset:0;
    background-image: var(--photoUrl);
    background-size: cover;         /* fill behind (may crop, but blurred) */
    background-position: center center;
    background-repeat: no-repeat;
    filter: blur(18px) brightness(0.85);
    transform: scale(1.08);
    opacity: 0.85;
    z-index: 0;
    pointer-events:none;
  }
  #playPanel.photoBgActive > *{
    position: relative;
    z-index: 1;
  }


  /* Upload icon button */
  .bgSwatch.upload {
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .bgSwatch.upload svg{
    width:16px; height:16px;
    fill: currentColor;
    opacity:0.9;
  }
</style>

</head>

<body>
<header>
  <div id="controls">
    <button id="startBtn" class="primary">Play</button>
    
    <div id="missBar" class="missBar" title="Mistakes allowed (resets each round)">
      <span class="missDot"></span><span class="missDot"></span><span class="missDot"></span>
    </div>
<button id="endBtn" title="End game and show score">End Game</button>

    <div id="level">N = 2</div>

    <div class="bg-palette-wrap" aria-label="Background">
      <span class="bg-label">Background</span>
      <div id="bgPalette" class="bg-palette" role="listbox" aria-label="Background colors"></div>
    </div>

    <div class="tune-wrap" aria-label="Training tuning">
      <div class="tune" role="group" aria-label="Timing">
        <span class="tune-label">Timing</span>
        <button class="tune-btn" id="paceMinus" aria-label="Timing down">−</button>
        <div class="dots" id="paceDots" aria-hidden="true"></div>
        <button class="tune-btn" id="pacePlus" aria-label="Timing up">+</button>
      </div>

      <div class="tune" role="group" aria-label="Circle size">
        <span class="tune-label">Size</span>
        <button class="tune-btn" id="sizeMinus" aria-label="Size down">−</button>
        <div class="dots" id="sizeDots" aria-hidden="true"></div>
        <button class="tune-btn" id="sizePlus" aria-label="Size up">+</button>
      </div>
    </div>

  </div>

  <div style="display:flex; gap:10px; align-items:center;">
    <div id="status">Press Play once. Then it runs continuously.</div>
    <button id="closeBtn" title="Close">✕</button>
  </div>
</header>

<div id="gameWrap">
  <div id="game">
    <div id="arena"></div>
    <svg id="linesLayer" aria-hidden="true"></svg>

    <div id="overlay" role="dialog" aria-modal="true">
      <div id="panel">
        <h2>Final Score</h2>
        <div id="score">N = 2</div>
        <p>
          This is the <b>highest N</b> you reached in this session.
          (In Dropbox, you may still need to close the preview tab/window manually.)
        </p>
        <div class="row">
          <button id="restartFromOverlay">Play Again</button>
          <button id="closeFromOverlay">Close</button>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
(() => {
  const game   = document.getElementById("game");
  const arena  = document.getElementById("arena");
  const startBtn = document.getElementById("startBtn");
  

  // ---- Forgiving misses (kid-friendly) ----
  const MISS_LIMIT = 3;     // per round
  let missesUsed = 0;
  const missBar = document.getElementById("missBar");
  function renderMisses(){
    if(!missBar) return;
    const dots = [...missBar.querySelectorAll(".missDot")];
    dots.forEach((d,i)=> d.classList.toggle("used", i < missesUsed));
  }

  function playFail(){
    // distinct fail sound (short descending buzz), safe if audio blocked
    try{
      if(!audioCtx) return;
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sawtooth";
      o.frequency.setValueAtTime(240, t0);
      o.frequency.exponentialRampToValueAtTime(120, t0 + 0.18);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.20, t0 + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t0); o.stop(t0 + 0.24);
    }catch(e){}
  }

  function playShimmerMelody(){
    // Brief, pleasant 3-note sparkle to accompany the gold shimmer cue.
    // Safe if audio is blocked; uses the existing AudioContext.
    try{
      const ctx = ensureAudio();
      const now = ctx.currentTime;

      const notes = [659.25, 783.99, 987.77]; // E5, G5, B5
      const dur = 0.11;
      const gap = 0.03;

      notes.forEach((f, i) => {
        const t0 = now + i*(dur+gap);
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "triangle";
        o.frequency.setValueAtTime(f, t0);

        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(0.18, t0 + 0.015);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        o.connect(g); g.connect(ctx.destination);
        o.start(t0);
        o.stop(t0 + dur + 0.02);
      });
    }catch(e){}
  }

const endBtn = document.getElementById("endBtn");
  const closeBtn = document.getElementById("closeBtn");
  const statusEl = document.getElementById("status");
  const levelEl  = document.getElementById("level");

  // --- v19: Tuning module (no numbers; dot preview) ---
  const paceMinus = document.getElementById("paceMinus");
  const pacePlus  = document.getElementById("pacePlus");
  const sizeMinus = document.getElementById("sizeMinus");
  const sizePlus  = document.getElementById("sizePlus");
  const paceDots  = document.getElementById("paceDots");
  const sizeDots  = document.getElementById("sizeDots");

  // Levels 1..5 (3 is default)
  let paceLevel = 3;
  let sizeLevel = 3;

  function makeDots(el){
    if(!el) return;
    el.innerHTML = "";
    for(let i=0;i<5;i++){
      const d=document.createElement("div");
      d.className="dot";
      el.appendChild(d);
    }
  }
  makeDots(paceDots);
  makeDots(sizeDots);

  function setDots(el, level){
    if(!el) return;
    const kids=[...el.children];
    kids.forEach((d,i)=> d.classList.toggle("on", i < level));
  }

  function applyPace(){
    // paceLevel 1 fastest -> 5 slowest
    // More noticeable multipliers: 0.60, 0.80, 1.00, 1.35, 1.75
    const mult = [0.60, 0.80, 1.00, 1.35, 1.75][paceLevel-1];
    SHOW_MS = Math.round(700 * mult);
    GAP_MS  = Math.round(300 * mult);
    setDots(paceDots, paceLevel);
  }

  function applySize(){
    // sizeLevel 1 small -> 5 large
    RECALL_RADIUS = [16, 20, 24, 30, 36][sizeLevel-1];
    setDots(sizeDots, sizeLevel);
  }

  function initTuning(){
    applyPace(); applySize();
    if(paceMinus) paceMinus.addEventListener("click", ()=>{ paceLevel=Math.max(1, paceLevel-1); applyPace(); });
    if(pacePlus)  pacePlus .addEventListener("click", ()=>{ paceLevel=Math.min(5, paceLevel+1); applyPace(); });
    if(sizeMinus) sizeMinus.addEventListener("click", ()=>{ sizeLevel=Math.max(1, sizeLevel-1); applySize(); });
    if(sizePlus)  sizePlus .addEventListener("click", ()=>{ sizeLevel=Math.min(5, sizeLevel+1); applySize(); });
  }

  const overlay = document.getElementById("overlay");
  const scoreEl = document.getElementById("score");
  const restartFromOverlay = document.getElementById("restartFromOverlay");
  const closeFromOverlay = document.getElementById("closeFromOverlay");

  const linesLayer = document.getElementById("linesLayer");

  function clearLines(){
    while (linesLayer.firstChild) linesLayer.removeChild(linesLayer.firstChild);
  }

  function syncLinesViewport(){
    // Keep SVG coordinate system in the same pixel space as the #game box.
    const r = game.getBoundingClientRect();
    linesLayer.setAttribute("viewBox", `0 0 ${r.width} ${r.height}`);
    linesLayer.setAttribute("preserveAspectRatio", "none");
  }

  function drawLine(from, to){
    // from/to are in game-local coordinates (same as circle cx/cy).
    syncLinesViewport();
    const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
    ln.setAttribute("x1", from.cx);
    ln.setAttribute("y1", from.cy);
    ln.setAttribute("x2", to.cx);
    ln.setAttribute("y2", to.cy);
    ln.setAttribute("opacity", "0.85");
    linesLayer.appendChild(ln);
  }


  // ---------- Tuning knobs ----------
  const MIN_N = 2;
  const MAX_N = 30;

  let SHOW_MS = 650;
  let GAP_MS  = 250;

  const SHOW_RADIUS_MIN = 34;
  const SHOW_RADIUS_MAX = 54;

  let RECALL_RADIUS   = 22;    // adjustable size for recall
  const PADDING_BETWEEN = 12;    // non-overlap margin

  const BETWEEN_ROUNDS_MS = 900; // pause after success/fail

  // pre-round cue
  const PRE_ROUND_DELAY_MS = 650;
  const FLICKER_COUNT = 2;
  const FLICKER_STEP_MS = 90;

  // ---------- Distinct primary-ish colors ----------
  const COLOR_PALETTE = [
    { name:"red",     h:  0,  s:92, l:58 },
    { name:"blue",    h:210,  s:92, l:58 },
    { name:"yellow",  h: 52,  s:95, l:55 },
    { name:"green",   h:120,  s:85, l:48 },
    { name:"magenta", h:305,  s:88, l:58 },
    { name:"cyan",    h:185,  s:92, l:55 },
    { name:"orange",  h: 28,  s:95, l:56 },
    { name:"violet",  h:260,  s:88, l:60 },
    { name:"lime",    h: 85,  s:92, l:52 },
    { name:"pink",    h:330,  s:90, l:60 },
    { name:"teal",    h:165,  s:80, l:48 },
    { name:"amber",   h: 42,  s:95, l:56 },
  ];

  // ---------- Bold, distinct tones (fixed mapping) ----------
  const NOTE_FREQS = [
    220.00, 261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 659.25,
    783.99, 880.00, 987.77, 1046.50
  ];
  const WAVEFORMS = ["sine", "triangle", "square", "sawtooth"];

  let audioCtx = null;
  function ensureAudio() {
    audioCtx ??= new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    return audioCtx;
  }

  function playToneForIndex(idx, ms=140) {
    const ctx = ensureAudio();
    const o = ctx.createOscillator();
    const g = ctx.createGain();

    o.frequency.value = NOTE_FREQS[idx % NOTE_FREQS.length];
    o.type = WAVEFORMS[idx % WAVEFORMS.length];

    const now = ctx.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.22, now + 0.008);
    g.gain.exponentialRampToValueAtTime(0.0001, now + ms/1000);

    o.detune.setValueAtTime(0, now);
    o.detune.linearRampToValueAtTime(6, now + 0.03);
    o.detune.linearRampToValueAtTime(0, now + 0.09);

    o.connect(g); g.connect(ctx.destination);
    o.start(now);
    o.stop(now + ms/1000 + 0.03);
  }

  // ---------- Helpers ----------
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));
  const rand  = (a,b) => Math.random()*(b-a)+a;
  const clamp = (v,lo,hi) => Math.max(lo, Math.min(hi, v));
  const dist  = (a,b) => Math.hypot(a.cx-b.cx, a.cy-b.cy);

  function setStatus(s){ statusEl.textContent = s; }
  function setLevel(){ levelEl.textContent = `N = ${N}`; }

  // ---------- iOS / anti-jump ----------
  function lockViewport(){
    document.documentElement.style.overflow = "hidden";
    document.body.style.overflow = "hidden";
    document.body.style.position = "fixed";
    document.body.style.inset = "0";
    document.body.style.width = "100%";
    window.scrollTo(0,0);
  }
  function unlockViewport(){
    document.documentElement.style.overflow = "hidden";
    document.body.style.overflow = "hidden";
  }

  window.addEventListener("resize", () => {
    if (phase !== "idle") window.scrollTo(0,0);
  });

  const _lockToTop = () => { try { window.scrollTo(0,0); } catch(e){} };

  window.addEventListener("scroll", () => {
    if (phase !== "idle") _lockToTop();
  }, { passive:true });

  if (window.visualViewport) {
    window.visualViewport.addEventListener("resize", () => {
      if (phase !== "idle") _lockToTop();
    });
    window.visualViewport.addEventListener("scroll", () => {
      if (phase !== "idle") _lockToTop();
    });
  }

  document.addEventListener("touchmove", (e) => {
    if (phase !== "idle") e.preventDefault();
  }, { passive:false });

  const _isInteractive = (t) => !!(t && (t.closest?.(".circle") || t.closest?.("button") || t.closest?.("select")));

  document.addEventListener("touchstart", (e) => {
    if (phase !== "idle" && !_isInteractive(e.target)) e.preventDefault();
  }, { passive:false });

  document.addEventListener("touchend", (e) => {
    if (phase !== "idle" && !_isInteractive(e.target)) e.preventDefault();
  }, { passive:false });

  // ---------- Background palette (modular) ----------
  const BACKGROUND_THEMES = {
    deepBlue: { name:"Deep Blue", swatch:"#1a2a5a", bgA:"#1a2a5a", bgB:"#0b1020", gameA:"rgba(16,26,53,0.78)", gameB:"rgba(16,26,53,0.78)" },
    charcoal:{ name:"Charcoal", swatch:"#2a2a2a", bgA:"#2a2a2a", bgB:"#0b0b0b", gameA:"rgba(28,28,28,0.82)", gameB:"rgba(18,18,18,0.82)" },
    forest:  { name:"Forest",   swatch:"#1b4a3a", bgA:"#1b4a3a", bgB:"#07120e", gameA:"rgba(12,34,26,0.82)", gameB:"rgba(12,34,26,0.82)" },
    plum:    { name:"Plum",     swatch:"#4a1b4a", bgA:"#4a1b4a", bgB:"#0f0610", gameA:"rgba(34,12,35,0.82)", gameB:"rgba(34,12,35,0.82)" },
    sand:    { name:"Sand",     swatch:"#c9b07a", bgA:"#c9b07a", bgB:"#2c2416", gameA:"rgba(44,36,22,0.78)", gameB:"rgba(44,36,22,0.78)" },
  };

  function applyBackgroundTheme(key){
    const t = BACKGROUND_THEMES[key] || BACKGROUND_THEMES.deepBlue;
    const r = document.documentElement.style;
    r.setProperty("--bgA", t.bgA);
    r.setProperty("--bgB", t.bgB);
    r.setProperty("--gameA", t.gameA);
    r.setProperty("--gameB", t.gameB);
  }

  // Module: renders swatches and manages selection state
  
  // ---- Photo background (local file; never uploaded) ----
  const bgFileInput = document.getElementById("bgFileInput");
  let photoBgUrl = null;

  function setPhotoBackground(dataUrl){
    photoBgUrl = dataUrl;
    const panel = document.getElementById("playPanel") || document.body;

    // Use CSS variable so both the sharp (contain) layer and blurred (cover) layer share the same image
    panel.style.setProperty("--photoUrl", `url(${dataUrl})`);
    panel.classList.add("photoBgActive");
    document.documentElement.classList.add("photoBgActive");
  }

  function clearPhotoBackground(){
    photoBgUrl = null;
    const panel = document.getElementById("playPanel") || document.body;
    panel.style.removeProperty("--photoUrl");
    panel.classList.remove("photoBgActive");
    document.documentElement.classList.remove("photoBgActive");
  }

  function openPhotoPicker(){
    try{ bgFileInput && bgFileInput.click(); }catch(e){}
  }

  if(bgFileInput){
    bgFileInput.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if(!file) return;
      if(!file.type || !file.type.startsWith("image/")) return;
      const reader = new FileReader();
      reader.onload = () => {
        if(typeof reader.result === "string") setPhotoBackground(reader.result);
      };
      reader.readAsDataURL(file);
      bgFileInput.value = "";
    });
  }


function initBackgroundPalette(opts){
    const {
      containerId = "bgPalette",
      defaultKey = "deepBlue",
      storageKey = "smt_bg_theme",
      onChange = () => {}
    } = (opts || {});

    const container = document.getElementById(containerId);
    if(!container) return { setTheme: applyBackgroundTheme };

    const keys = Object.keys(BACKGROUND_THEMES);

    function setSelected(key){
      [...container.querySelectorAll(".bg-swatch")].forEach(el=>{
        el.setAttribute("aria-selected", el.dataset.key === key ? "true" : "false");
      });
    }

    function setTheme(key){
      applyBackgroundTheme(key);
      setSelected(key);
      try{ localStorage.setItem(storageKey, key); }catch(e){}
      onChange(key);
    }

    // render
    container.innerHTML = "";
    keys.forEach((key)=>{
      const t = BACKGROUND_THEMES[key];
      const sw = document.createElement("button");
      sw.type = "button";
      sw.className = "bg-swatch";
      sw.title = t.name;
      sw.setAttribute("aria-selected", "false");
      sw.dataset.key = key;
      sw.style.background = t.swatch;
      sw.addEventListener("click", ()=> setTheme(key));
      container.appendChild(sw);
    });

    // initial selection (restore if possible)
    let initial = defaultKey;
    try{
      const saved = localStorage.getItem(storageKey);
      if(saved && BACKGROUND_THEMES[saved]) initial = saved;
    }catch(e){}
    setTheme(initial);

    // Photo swatch at end (opens image picker; long-press clears photo)
    const photo = document.createElement("button");
    photo.type = "button";
    photo.className = "bgSwatch upload";
    photo.title = "Upload photo background";
    photo.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5 20h14v-2H5v2zm7-16l-5 5h3v4h4v-4h3l-5-5z"/></svg>`;
    photo.setAttribute("role","option");
    photo.addEventListener("click", () => { openPhotoPicker(); });

    let pressTimer = null;
    photo.addEventListener("pointerdown", () => { pressTimer = setTimeout(() => { clearPhotoBackground(); }, 650); });
    photo.addEventListener("pointerup", () => { if(pressTimer) clearTimeout(pressTimer); pressTimer=null; });
    photo.addEventListener("pointercancel", () => { if(pressTimer) clearTimeout(pressTimer); pressTimer=null; });

    container.appendChild(photo);

  return { setTheme };
  }

  initBackgroundPalette({ defaultKey: "deepBlue" });
  initTuning();

  // ---------- Gold transition ----------
  async function goldTransition(token){
    // Calm between-round cue: brief warm glow without flicker.
    if (token !== runToken) return;
    
    playShimmerMelody();
game.classList.add("goldGlow");
    game.classList.add("goldB");
    await sleep(260);
    game.classList.remove("goldB");
    game.classList.remove("goldGlow");
  }

  async function preRoundCue(token) {
    // Calm start: no screen flicker; just a short settle pause.
    await sleep(PRE_ROUND_DELAY_MS);
  }

  // ---------- Game state ----------
  let N = 2;
  let phase = "idle"; // idle | showing | recall | transition | ended
  let expectedIndex = 0;

  let circles = [];
  let runToken = 0;

  let maxNThisSession = 2;

  function clearBoard() {
    circles.forEach(c => c.el?.remove());
    circles = [];
    expectedIndex = 0;
    clearLines();
  }

  function arenaRectInGameCoords() {
    const g = game.getBoundingClientRect();
    const a = arena.getBoundingClientRect();
    return {
      left: a.left - g.left,
      top:  a.top  - g.top,
      width: a.width,
      height: a.height
    };
  }

  function makeCircleElement(c) {
    const el = document.createElement("div");
    el.className="circle";

    const {h,s,l} = c.color;
    el.style.background = `radial-gradient(circle at 30% 30%,
      rgba(255,255,255,0.55),
      hsl(${h} ${s}% ${l}%))`;

    el.addEventListener("pointerdown", (e) => {
      if (phase !== "recall") return;
      handleClick(c);
      e.preventDefault();
    });

    game.appendChild(el);
    c.el = el;
  }

  function setCircleGeometry(c, r) {
    c.el.style.width  = `${2*r}px`;
    c.el.style.height = `${2*r}px`;
    c.el.style.left   = `${c.cx - r}px`;
    c.el.style.top    = `${c.cy - r}px`;
  }

  function nonOverlappingPlacement(n) {
    const ar = arenaRectInGameCoords();
    const placed = [];

    for (let i=0; i<n; i++) {
      let ok = false;

      for (let tries=0; tries<250; tries++) {
        const rShow = Math.max(RECALL_RADIUS, rand(SHOW_RADIUS_MIN, SHOW_RADIUS_MAX));
        const cx = rand(ar.left + rShow, ar.left + ar.width  - rShow);
        const cy = rand(ar.top  + rShow, ar.top  + ar.height - rShow);
        const candidate = { cx, cy, rShow };

        const tooClose = placed.some(p => dist(candidate, p) < (candidate.rShow + p.rShow + PADDING_BETWEEN));
        if (!tooClose) {
          ok = true;
          placed.push({ cx, cy, rShow });
          break;
        }
      }

      if (!ok) {
        const rShow = Math.max(RECALL_RADIUS, rand(SHOW_RADIUS_MIN, SHOW_RADIUS_MAX));
        const cx = rand(ar.left + rShow, ar.left + ar.width  - rShow);
        const cy = rand(ar.top  + rShow, ar.top  + ar.height - rShow);
        placed.push({ cx, cy, rShow });
      }
    }
    return placed;
  }

  async function runRound(token) {
    // Reset misses at the start of each round
    missesUsed = 0;
    renderMisses();

    phase = "transition";
    clearBoard();
    syncLinesViewport();
    setLevel();

    setStatus("Get ready…");
    await preRoundCue(token);
    if (token !== runToken) return;

    phase = "showing";
    setStatus(`Watch the sequence… (${N})`);

    // Place circles without overlap and assign randomized colors (sound stays deterministic by index)
    let prevColor = null;
    circles = nonOverlappingPlacement(N).map((pos, i) => {
      let color = COLOR_PALETTE[Math.floor(Math.random() * COLOR_PALETTE.length)];
      if (prevColor && color === prevColor) {
        color = COLOR_PALETTE[(COLOR_PALETTE.indexOf(color) + 1) % COLOR_PALETTE.length];
      }
      prevColor = color;

      const freq  = NOTE_FREQS[i % NOTE_FREQS.length];
      const wave  = WAVEFORMS[i % WAVEFORMS.length];
      return { ...pos, index:(i+1), color, freq, wave, el:null };
    });

    circles.forEach(c => {
      makeCircleElement(c);
      setCircleGeometry(c, c.rShow);
      c.el.classList.remove("wrong","visible","glow");
    });

    for (let i=0; i<N; i++) {
      if (token !== runToken) return;
      const c = circles[i];

      // Keep already-shown circles on-screen (dim), highlight current one.
      for (let j=0; j<i; j++){
        const p = circles[j];
        p.el.classList.add("visible");
        p.el.classList.remove("active");
        p.el.classList.add("dim");
      }

      // Draw the line from previous to current (center-to-center)
      if (i > 0) drawLine(circles[i-1], c);

      c.el.classList.add("visible");
      c.el.classList.remove("dim");
      c.el.classList.add("active");

      playToneForIndex(c.index, Math.min(190, Math.floor(SHOW_MS*0.30)));
      await sleep(SHOW_MS);

      // After its turn, keep it on-screen but dimmed (no popping)
      c.el.classList.remove("active");
      c.el.classList.add("dim");

      await sleep(GAP_MS);
    }

    // NEW: erase lines before player starts clicking
    clearLines();

    // Calm transition: remove dim/active styling before recall layout
    circles.forEach(c => {
      c.el.classList.remove("active","dim");
      // hide briefly to avoid size-teleport feeling
      c.el.classList.remove("visible");
    });
    await sleep(120);

    phase = "recall";
    expectedIndex = 0;

    circles.forEach(c => {
      setCircleGeometry(c, RECALL_RADIUS);
      c.el.classList.add("visible");
    });

    setStatus(`Your turn: click in order (1 → ${N}).`);
  }

  function handleClick(circleObj) {
    const i = circleObj.index;

    if (i === expectedIndex) {
      playToneForIndex(circleObj.index, 135);

      circleObj.el.classList.add("glow");
      setTimeout(() => circleObj.el?.classList.remove("glow"), 160);

      setTimeout(() => circleObj.el?.remove(), 40);

      expectedIndex++;
      if (expectedIndex >= N) onSuccess();
      else setStatus(`Good! Next: ${expectedIndex + 1} of ${N}.`);
    } else {
      // Wrong click: allow up to MISS_LIMIT misses per round (do not end immediately)
      playFail();
      missesUsed = Math.min(MISS_LIMIT, missesUsed + 1);
      renderMisses();

      circleObj.el.classList.add("wrong");
      setTimeout(() => circleObj.el?.classList.remove("wrong"), 260);

      const remaining = MISS_LIMIT - missesUsed;
      if (remaining > 0) {
        setStatus(`Almost! Try again — ${remaining} miss${remaining===1?"":"es"} left this round.`);
        return; // keep playing this round
      } else {
        setStatus(`Out of chances this round.`);
        onFailure();
      }
    }
  }

  async function onSuccess() {
    phase = "transition";
    maxNThisSession = Math.max(maxNThisSession, N);
    setStatus(`✅ Success! Next round…`);
    await goldTransition(runToken);
    N = clamp(N + 1, MIN_N, MAX_N);
    await sleep(BETWEEN_ROUNDS_MS);
    if (phase !== "transition") return;
    await runRound(runToken);
  }

  async function onFailure() {
    phase = "transition";
    maxNThisSession = Math.max(maxNThisSession, N);
    setStatus(`❌ Wrong order. Adjusting…`);
    await goldTransition(runToken);
    N = clamp(N - 1, MIN_N, MAX_N);
    await sleep(BETWEEN_ROUNDS_MS);
    if (phase !== "transition") return;
    await runRound(runToken);
  }

  function showFinalScore(){
    phase = "ended";
    clearBoard();
    scoreEl.textContent = `N = ${maxNThisSession}`;
    overlay.classList.add("show");
    setStatus("Game ended.");
    levelEl.textContent = `N = ${N}`;
  }

  function attemptClose(){
  // Mobile browsers generally block window.close(). Instead, just dismiss overlays/panels.
  overlay.classList.remove("show");
}

  function endGame(){
    runToken++;
    showFinalScore();
  }

  endBtn.addEventListener("click", () => {
    ensureAudio();
    endGame();
  });

  closeBtn.addEventListener("click", () => {
    ensureAudio();
    endGame();
  });

  closeFromOverlay.addEventListener("click", () => {
    attemptClose();
  });

  restartFromOverlay.addEventListener("click", () => {
    overlay.classList.remove("show");
    startGame();
  });

  function startGame(){
    ensureAudio();
    lockViewport();
    runToken++;
    phase = "idle";
    N = 2;
    maxNThisSession = 2;
    setLevel();
    clearBoard();
    setStatus("Starting…");
    sleep(120).then(async () => { await goldTransition(runToken); await runRound(runToken); });
}

  startBtn.addEventListener("click", () => startGame());

})();

  renderMisses();
</script>


  <input id="bgFileInput" type="file" accept="image/*" style="display:none" />
</body>
</html>
