<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Spatial Memory Trainer</title>

<style>
  :root{
    --bg:#0b1020;
    --panel:#111a33;
    --arena:#101a35;
    --text:#eef;
    --muted:#b7c0ee;

    --flash1:#1f2f66;
    --flash2:#0d1633;

    /* chosen by dropdown */
    --bgA:#1a2a5a;
    --bgB:#0b1020;

    --gameA: rgba(16,26,53,0.78);
    --gameB: rgba(16,26,53,0.78);
  }

  html, body{ height:100%; width:100%; overflow:hidden; }
  body{
    margin:0;
    background: radial-gradient(1000px 700px at 50% 10%, var(--bgA), var(--bgB));
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    display:grid;
    grid-template-rows:auto 1fr;
    height:100dvh;
    position:fixed;
    inset:0;
    overflow:hidden;
  }

  header{
    padding:10px 14px;
    display:flex;
    flex-direction:column;
    align-items:stretch;
    justify-content:flex-start;
    background: rgba(17,26,51,0.88);
    border-bottom: 1px solid rgba(255,255,255,0.10);
    gap:10px;
  }

  #status{ color:var(--muted); font-size:14px; }
  #level { font-size:14px; }
  #controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

  button{
    padding:7px 12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.10);
    color:var(--text);
    cursor:pointer;
  }
  button:hover{ background: rgba(255,255,255,0.16); }

  select{
    padding:7px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.10);
    color:var(--text);
    outline:none;
  }
  option{ color:#111; }

  #closeBtn{
    font-size:16px;
    line-height:1;
    padding:7px 12px;
  }

  #gameWrap{
    display:grid;
    place-items:center;
    padding:12px;
    padding-bottom: calc(12px + env(safe-area-inset-bottom));
  }

  #game{
    touch-action: none;
    position:relative;
    width:min(900px, 96vw);
    height:min(600px, 72vh);
    background: radial-gradient(900px 650px at 50% 35%, var(--gameA), var(--gameB));
    border:1px solid rgba(255,255,255,0.12);
    border-radius:18px;
    overflow:hidden;
    box-shadow: 0 20px 70px rgba(0,0,0,0.35);
    transition: background 160ms ease, box-shadow 220ms ease;
  }

  #game.flashA{ background: rgba(31,47,102,0.88); }
  #game.flashB{ background: rgba(13,22,51,0.92); }

  /* Gold success/failure transition */
  #game.goldA{
    background: radial-gradient(900px 650px at 50% 35%,
      rgba(255,236,170,0.88),
      rgba(255,196,80,0.58),
      rgba(16,26,53,0.92));
  }
  #game.goldB{
    background: radial-gradient(900px 650px at 50% 35%,
      rgba(255,250,210,0.95),
      rgba(255,215,120,0.66),
      rgba(16,26,53,0.94));
  }
  #game.goldGlow{
    box-shadow:
      0 0 0 3px rgba(255,215,120,0.35),
      0 0 45px rgba(255,215,120,0.95),
      0 0 110px rgba(255,215,120,0.60),
      0 0 180px rgba(255,215,120,0.28),
      0 20px 70px rgba(0,0,0,0.35);
  }

  /* Central arena (invisible boundary for placement) */
  #arena{
    position:absolute;
    left:15%;
    top:20%;
    width:70%;
    height:60%;
    pointer-events:none;
  }

  .circle{
    position:absolute;
    border-radius:50%;
    border:2px solid rgba(255,255,255,0.22);
    box-shadow: 0 10px 25px rgba(0,0,0,0.25);
    opacity:0;
    transform: scale(0.96);
    transition: opacity 160ms ease, transform 160ms ease, left 160ms ease, top 160ms ease, width 160ms ease, height 160ms ease;
    -webkit-tap-highlight-color: transparent;
    user-select:none;
    touch-action: manipulation;
    overscroll-behavior: none;
  }
  .circle.visible{ opacity:1; transform: scale(1); }

  /* Calmer encoding: keep previously shown circles lightly visible */
  .circle.dim{
    opacity: 0.35 !important;
    transform: scale(0.985);
    filter: saturate(0.95);
  }
  .circle.active{
    opacity: 1 !important;
    transform: scale(1.03);
    border-color: rgba(255,255,255,0.34);
    box-shadow:
      0 0 0 3px rgba(255,255,255,0.14),
      0 10px 25px rgba(0,0,0,0.25);
  }

  .circle.wrong{
    border-color: rgba(255,120,120,0.95);
    box-shadow: 0 0 0 4px rgba(255,120,120,0.18), 0 10px 25px rgba(0,0,0,0.25);
  }
  .circle.glow{
    border-color: rgba(255,215,120,0.98);
    box-shadow:
      0 0 0 4px rgba(255,215,120,0.28),
      0 0 22px rgba(255,215,120,0.90),
      0 0 46px rgba(255,215,120,0.60),
      0 10px 25px rgba(0,0,0,0.25);
    transition: box-shadow 220ms ease, border-color 220ms ease;
  }


  /* Lines layer (sequence connections) */
  #linesLayer{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    pointer-events:none;
    overflow:visible;
  }
  #linesLayer line{
    stroke: rgba(255,255,255,0.55);
    stroke-width: 2.25;
    stroke-linecap: round;
  }

  /* End screen */
  #overlay{
    position:absolute;
    inset:0;
    background: rgba(0,0,0,0.55);
    display:none;
    align-items:center;
    justify-content:center;
    padding:18px;
  }
  #overlay.show{ display:flex; }
  #panel{
    width:min(520px, 92vw);
    background: rgba(17,26,51,0.94);
    border:1px solid rgba(255,255,255,0.14);
    border-radius:18px;
    box-shadow: 0 25px 90px rgba(0,0,0,0.55);
    padding:18px 18px 14px;
  }
  #panel h2{
    margin:0 0 8px;
    font-size:20px;
    font-weight:800;
    letter-spacing:0.2px;
  }
  #score{
    margin:10px 0 14px;
    font-size:34px;
    font-weight:900;
  }
  #panel p{
    margin:0 0 14px;
    color:var(--muted);
    line-height:1.35;
  }
  #panel .row{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:flex-end;
  }

  #controls, #rightBar{
    display:flex;
    align-items:center;
    gap:10px;
    flex-wrap:nowrap;
  }
  #rightBar{ justify-content:space-between; }
  #bgRowPanel{
    display:flex;
    align-items:center;
    gap:10px;
    padding:6px 10px;
    border-radius:14px;
    background: rgba(255,255,255,0.06);
    border:1px solid rgba(255,255,255,0.10);
  }


  /* --- Two-panel layout: top panel + play panel --- */
  header{
    display:flex;
    flex-direction:column;
    gap:10px;
    padding:10px 14px;
    background: rgba(17,26,51,0.92);
    border-bottom: 1px solid rgba(255,255,255,0.10);
  }

  #bgRowPanel{
    display:flex;
    align-items:center;
    gap:10px;
  }
  #bgRowLabel{
    color:var(--muted);
    font-size:14px;
    flex: 0 0 auto;
  }
  #bgSwatches{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:nowrap;
    overflow-x:auto;
    -webkit-overflow-scrolling:touch;
    padding-bottom:2px;
  }
  .bgSwatchBtn{
    appearance:none;
    -webkit-appearance:none;
    padding:0;
    width:34px;
    height:34px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.45);
    box-shadow: 0 6px 14px rgba(0,0,0,0.22);
    cursor:pointer;
    position:relative;
    background: transparent;
    flex: 0 0 auto;
  }
  .bgSwatchBtn:active{ transform: scale(0.98); }
  .bgSwatchBtn.isOn{
    border-color: rgba(255,255,255,0.95);
    box-shadow:
      0 0 0 2px rgba(255,255,255,0.28),
      0 6px 14px rgba(0,0,0,0.22);
  }
  .bgSwatchBtn.isOn::after{
    content:"";
    position:absolute;
    inset:7px;
    border-radius:8px;
    border:2px solid rgba(255,255,255,0.80);
    pointer-events:none;
  }

  /* Hide the original dropdown but keep it for stability */
  #bgSelect{ display:none !important; }

</style>
</head>

<body>
<header>
  <div id="controls">
    <button id="startBtn">Start / Reset</button>
    <button id="endBtn" title="End game and show score">End Game</button>

    <div id="level">N = 2</div>

    <label style="display:flex; gap:8px; align-items:center;">
      <span style="color:var(--muted); font-size:14px;">Background</span>
      <select id="bgSelect" title="Choose background">
        <option value="deepBlue" selected>Deep Blue</option>
        <option value="charcoal">Charcoal</option>
        <option value="forest">Forest</option>
        <option value="plum">Plum</option>
        <option value="sand">Sand</option>
      </select>
    </label>
  </div>

  <div id="rightBar" style="display:flex; gap:10px; align-items:center;">
    <div id="status">Press Start once. Then it runs continuously.</div>
    <button id="closeBtn" title="Close">✕</button>
  </div>

  <div id="bgRowPanel">
    <div id="bgRowLabel">Background</div>
    <div id="bgSwatches"></div>
  </div>

</header>

<div id="gameWrap">
  <div id="game">
    <div id="arena"></div>
    <svg id="linesLayer" aria-hidden="true"></svg>

    <div id="overlay" role="dialog" aria-modal="true">
      <div id="panel">
        <h2>Final Score</h2>
        <div id="score">N = 2</div>
        <p>
          This is the <b>highest N</b> you reached in this session.
          (In Dropbox, you may still need to close the preview tab/window manually.)
        </p>
        <div class="row">
          <button id="restartFromOverlay">Play Again</button>
          <button id="closeFromOverlay">Close</button>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
(() => {
  const game   = document.getElementById("game");
  const arena  = document.getElementById("arena");
  const startBtn = document.getElementById("startBtn");
  const endBtn = document.getElementById("endBtn");
  const closeBtn = document.getElementById("closeBtn");
  const statusEl = document.getElementById("status");
  const levelEl  = document.getElementById("level");

  const bgSelect = document.getElementById("bgSelect");

  const overlay = document.getElementById("overlay");
  const scoreEl = document.getElementById("score");
  const restartFromOverlay = document.getElementById("restartFromOverlay");
  const closeFromOverlay = document.getElementById("closeFromOverlay");

  const linesLayer = document.getElementById("linesLayer");

  function clearLines(){
    while (linesLayer.firstChild) linesLayer.removeChild(linesLayer.firstChild);
  }

  function syncLinesViewport(){
    // Keep SVG coordinate system in the same pixel space as the #game box.
    const r = game.getBoundingClientRect();
    linesLayer.setAttribute("viewBox", `0 0 ${r.width} ${r.height}`);
    linesLayer.setAttribute("preserveAspectRatio", "none");
  }

  function drawLine(from, to){
    // from/to are in game-local coordinates (same as circle cx/cy).
    syncLinesViewport();
    const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
    ln.setAttribute("x1", from.cx);
    ln.setAttribute("y1", from.cy);
    ln.setAttribute("x2", to.cx);
    ln.setAttribute("y2", to.cy);
    ln.setAttribute("opacity", "0.85");
    linesLayer.appendChild(ln);
  }


  // ---------- Tuning knobs ----------
  const MIN_N = 2;
  const MAX_N = 30;

  const SHOW_MS = 650;
  const GAP_MS  = 250;

  const SHOW_RADIUS_MIN = 34;
  const SHOW_RADIUS_MAX = 54;

  const RECALL_RADIUS   = 22;    // fixed small size for recall
  const PADDING_BETWEEN = 12;    // non-overlap margin

  const BETWEEN_ROUNDS_MS = 900; // pause after success/fail

  // pre-round cue
  const PRE_ROUND_DELAY_MS = 650;
  const FLICKER_COUNT = 2;
  const FLICKER_STEP_MS = 90;

  // ---------- Distinct primary-ish colors ----------
  const COLOR_PALETTE = [
    { name:"red",     h:  0,  s:92, l:58 },
    { name:"blue",    h:210,  s:92, l:58 },
    { name:"yellow",  h: 52,  s:95, l:55 },
    { name:"green",   h:120,  s:85, l:48 },
    { name:"magenta", h:305,  s:88, l:58 },
    { name:"cyan",    h:185,  s:92, l:55 },
    { name:"orange",  h: 28,  s:95, l:56 },
    { name:"violet",  h:260,  s:88, l:60 },
    { name:"lime",    h: 85,  s:92, l:52 },
    { name:"pink",    h:330,  s:90, l:60 },
    { name:"teal",    h:165,  s:80, l:48 },
    { name:"amber",   h: 42,  s:95, l:56 },
  ];

  // ---------- Bold, distinct tones (fixed mapping) ----------
  const NOTE_FREQS = [
    220.00, 261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 659.25,
    783.99, 880.00, 987.77, 1046.50
  ];
  const WAVEFORMS = ["sine", "triangle", "square", "sawtooth"];

  let audioCtx = null;
  function ensureAudio() {
    audioCtx ??= new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    return audioCtx;
  }

  function playToneForIndex(idx, ms=140) {
    const ctx = ensureAudio();
    const o = ctx.createOscillator();
    const g = ctx.createGain();

    o.frequency.value = NOTE_FREQS[idx % NOTE_FREQS.length];
    o.type = WAVEFORMS[idx % WAVEFORMS.length];

    const now = ctx.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.22, now + 0.008);
    g.gain.exponentialRampToValueAtTime(0.0001, now + ms/1000);

    o.detune.setValueAtTime(0, now);
    o.detune.linearRampToValueAtTime(6, now + 0.03);
    o.detune.linearRampToValueAtTime(0, now + 0.09);

    o.connect(g); g.connect(ctx.destination);
    o.start(now);
    o.stop(now + ms/1000 + 0.03);
  }

  // ---------- Helpers ----------
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));
  const rand  = (a,b) => Math.random()*(b-a)+a;
  const clamp = (v,lo,hi) => Math.max(lo, Math.min(hi, v));
  const dist  = (a,b) => Math.hypot(a.cx-b.cx, a.cy-b.cy);

  function setStatus(s){ statusEl.textContent = s; }
  function setLevel(){ levelEl.textContent = `N = ${N}`; }

  // ---------- iOS / anti-jump ----------
  function lockViewport(){
    document.documentElement.style.overflow = "hidden";
    document.body.style.overflow = "hidden";
    document.body.style.position = "fixed";
    document.body.style.inset = "0";
    document.body.style.width = "100%";
    window.scrollTo(0,0);
  }
  function unlockViewport(){
    document.documentElement.style.overflow = "hidden";
    document.body.style.overflow = "hidden";
  }

  window.addEventListener("resize", () => {
    if (phase !== "idle") window.scrollTo(0,0);
  });

  const _lockToTop = () => { try { window.scrollTo(0,0); } catch(e){} };

  window.addEventListener("scroll", () => {
    if (phase !== "idle") _lockToTop();
  }, { passive:true });

  if (window.visualViewport) {
    window.visualViewport.addEventListener("resize", () => {
      if (phase !== "idle") _lockToTop();
    });
    window.visualViewport.addEventListener("scroll", () => {
      if (phase !== "idle") _lockToTop();
    });
  }

  document.addEventListener("touchmove", (e) => {
    if (phase !== "idle") e.preventDefault();
  }, { passive:false });

  const _isInteractive = (t) => !!(t && (t.closest?.(".circle") || t.closest?.(".bgSwatchBtn") || t.closest?.("button") || t.closest?.("select")));

  document.addEventListener("touchstart", (e) => {
    if (phase !== "idle" && !_isInteractive(e.target)) e.preventDefault();
  }, { passive:false });

  document.addEventListener("touchend", (e) => {
    if (phase !== "idle" && !_isInteractive(e.target)) e.preventDefault();
  }, { passive:false });

  // ---------- Background dropdown ----------
  function applyBackgroundTheme(key){
    const themes = {
      deepBlue: { bgA:"#1a2a5a", bgB:"#0b1020", gameA:"rgba(16,26,53,0.78)", gameB:"rgba(16,26,53,0.78)" },
      charcoal:{ bgA:"#2a2a2a", bgB:"#0b0b0b", gameA:"rgba(28,28,28,0.82)", gameB:"rgba(18,18,18,0.82)" },
      forest:  { bgA:"#1b4a3a", bgB:"#07120e", gameA:"rgba(12,34,26,0.82)", gameB:"rgba(12,34,26,0.82)" },
      plum:    { bgA:"#4a1b4a", bgB:"#0f0610", gameA:"rgba(34,12,35,0.82)", gameB:"rgba(34,12,35,0.82)" },
      sand:    { bgA:"#c9b07a", bgB:"#2c2416", gameA:"rgba(44,36,22,0.78)", gameB:"rgba(44,36,22,0.78)" },
    };
    const t = themes[key] || themes.deepBlue;
    const r = document.documentElement.style;
    r.setProperty("--bgA", t.bgA);
    r.setProperty("--bgB", t.bgB);
    r.setProperty("--gameA", t.gameA);
    r.setProperty("--gameB", t.gameB);
  }

  bgSelect.addEventListener("change", () => {
    applyBackgroundTheme(bgSelect.value);

  // --- Always-visible background swatches row (uses existing bgSelect handler) ---
  const bgSwatches = document.getElementById("bgSwatches");
  const BG_KEYS = ["deepBlue","charcoal","forest","plum","sand"];
  const BG_SWATCH = {
    deepBlue:"#1a2a5a",
    charcoal:"#2a2a2a",
    forest:"#1b4a3a",
    plum:"#4a1b4a",
    sand:"#c9b07a",
  };

  function renderBgSwatches(){
    bgSwatches.innerHTML = "";
    BG_KEYS.forEach((key) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "bgSwatchBtn";
      btn.dataset.bg = key;
      btn.title = key;
      const c = BG_SWATCH[key] || "#1a2a5a";
      btn.style.background = `linear-gradient(135deg, rgba(255,255,255,0.18), rgba(0,0,0,0.18)), ${c}`;
      btn.addEventListener("click", () => {
        bgSelect.value = key;
        bgSelect.dispatchEvent(new Event("change"));
        [...bgSwatches.children].forEach(el => el.classList.toggle("isOn", el.dataset.bg === key));
      });
      bgSwatches.appendChild(btn);
    });
    [...bgSwatches.children].forEach(el => el.classList.toggle("isOn", el.dataset.bg === bgSelect.value));
  }

  renderBgSwatches();

  });
  applyBackgroundTheme(bgSelect.value);

  // ---------- Gold transition ----------
  async function goldTransition(token){
    // Calm between-round cue: brief warm glow without flicker.
    if (token !== runToken) return;
    game.classList.add("goldGlow");
    game.classList.add("goldB");
    await sleep(260);
    game.classList.remove("goldB");
    game.classList.remove("goldGlow");
  }

  async function preRoundCue(token) {
    // Calm start: no screen flicker; just a short settle pause.
    await sleep(PRE_ROUND_DELAY_MS);
  }

  // ---------- Game state ----------
  let N = 2;
  let phase = "idle"; // idle | showing | recall | transition | ended
  let expectedIndex = 0;

  let circles = [];
  let runToken = 0;

  let maxNThisSession = 2;

  function clearBoard() {
    circles.forEach(c => c.el?.remove());
    circles = [];
    expectedIndex = 0;
    clearLines();
  }

  function arenaRectInGameCoords() {
    const g = game.getBoundingClientRect();
    const a = arena.getBoundingClientRect();
    return {
      left: a.left - g.left,
      top:  a.top  - g.top,
      width: a.width,
      height: a.height
    };
  }

  function makeCircleElement(c) {
    const el = document.createElement("div");
    el.className="circle";

    const {h,s,l} = c.color;
    el.style.background = `radial-gradient(circle at 30% 30%,
      rgba(255,255,255,0.55),
      hsl(${h} ${s}% ${l}%))`;

    el.addEventListener("pointerdown", (e) => {
      if (phase !== "recall") return;
      handleClick(c);
      e.preventDefault();
    });

    game.appendChild(el);
    c.el = el;
  }

  function setCircleGeometry(c, r) {
    c.el.style.width  = `${2*r}px`;
    c.el.style.height = `${2*r}px`;
    c.el.style.left   = `${c.cx - r}px`;
    c.el.style.top    = `${c.cy - r}px`;
  }

  function nonOverlappingPlacement(n) {
    const ar = arenaRectInGameCoords();
    const placed = [];

    for (let i=0; i<n; i++) {
      let ok = false;

      for (let tries=0; tries<250; tries++) {
        const rShow = rand(SHOW_RADIUS_MIN, SHOW_RADIUS_MAX);
        const cx = rand(ar.left + rShow, ar.left + ar.width  - rShow);
        const cy = rand(ar.top  + rShow, ar.top  + ar.height - rShow);
        const candidate = { cx, cy, rShow };

        const tooClose = placed.some(p => dist(candidate, p) < (candidate.rShow + p.rShow + PADDING_BETWEEN));
        if (!tooClose) {
          ok = true;
          placed.push({ cx, cy, rShow });
          break;
        }
      }

      if (!ok) {
        const rShow = rand(SHOW_RADIUS_MIN, SHOW_RADIUS_MAX);
        const cx = rand(ar.left + rShow, ar.left + ar.width  - rShow);
        const cy = rand(ar.top  + rShow, ar.top  + ar.height - rShow);
        placed.push({ cx, cy, rShow });
      }
    }
    return placed;
  }

  async function runRound(token) {
    phase = "transition";
    clearBoard();
    syncLinesViewport();
    setLevel();

    setStatus("Get ready…");
    await preRoundCue(token);
    if (token !== runToken) return;

    phase = "showing";
    setStatus(`Watch the sequence… (${N})`);

    circles = nonOverlappingPlacement(N).map((pos, i) => {
      const color = COLOR_PALETTE[i % COLOR_PALETTE.length];
      const freq  = NOTE_FREQS[i % NOTE_FREQS.length];
      const wave  = WAVEFORMS[i % WAVEFORMS.length];
      return { ...pos, index:i, color, freq, wave, el:null };
    });

    circles.forEach(c => {
      makeCircleElement(c);
      setCircleGeometry(c, c.rShow);
      c.el.classList.remove("wrong","visible","glow");
    });

    for (let i=0; i<N; i++) {
      if (token !== runToken) return;
      const c = circles[i];

      // Keep already-shown circles on-screen (dim), highlight current one.
      for (let j=0; j<i; j++){
        const p = circles[j];
        p.el.classList.add("visible");
        p.el.classList.remove("active");
        p.el.classList.add("dim");
      }

      // Draw the line from previous to current (center-to-center)
      if (i > 0) drawLine(circles[i-1], c);

      c.el.classList.add("visible");
      c.el.classList.remove("dim");
      c.el.classList.add("active");

      playToneForIndex(c.index, Math.min(190, Math.floor(SHOW_MS*0.30)));
      await sleep(SHOW_MS);

      // After its turn, keep it on-screen but dimmed (no popping)
      c.el.classList.remove("active");
      c.el.classList.add("dim");

      await sleep(GAP_MS);
    }

    // NEW: erase lines before player starts clicking
    clearLines();

    // Calm transition: remove dim/active styling before recall layout
    circles.forEach(c => {
      c.el.classList.remove("active","dim");
      // hide briefly to avoid size-teleport feeling
      c.el.classList.remove("visible");
    });
    await sleep(120);

    phase = "recall";
    expectedIndex = 0;

    circles.forEach(c => {
      setCircleGeometry(c, RECALL_RADIUS);
      c.el.classList.add("visible");
    });

    setStatus(`Your turn: click in order (1 → ${N}).`);
  }

  function handleClick(circleObj) {
    const i = circleObj.index;

    if (i === expectedIndex) {
      playToneForIndex(circleObj.index, 135);

      circleObj.el.classList.add("glow");
      setTimeout(() => circleObj.el?.classList.remove("glow"), 160);

      setTimeout(() => circleObj.el?.remove(), 40);

      expectedIndex++;
      if (expectedIndex >= N) onSuccess();
      else setStatus(`Good! Next: ${expectedIndex + 1} of ${N}.`);
    } else {
      playToneForIndex(0, 180);
      circleObj.el.classList.add("wrong");
      setTimeout(() => circleObj.el?.classList.remove("wrong"), 260);
      onFailure();
    }
  }

  async function onSuccess() {
    phase = "transition";
    maxNThisSession = Math.max(maxNThisSession, N);
    setStatus(`✅ Success! Next round…`);
    await goldTransition(runToken);
    N = clamp(N + 1, MIN_N, MAX_N);
    await sleep(BETWEEN_ROUNDS_MS);
    if (phase !== "transition") return;
    await runRound(runToken);
  }

  async function onFailure() {
    phase = "transition";
    maxNThisSession = Math.max(maxNThisSession, N);
    setStatus(`❌ Wrong order. Adjusting…`);
    await goldTransition(runToken);
    N = clamp(N - 1, MIN_N, MAX_N);
    await sleep(BETWEEN_ROUNDS_MS);
    if (phase !== "transition") return;
    await runRound(runToken);
  }

  function showFinalScore(){
    phase = "ended";
    clearBoard();
    scoreEl.textContent = `N = ${maxNThisSession}`;
    overlay.classList.add("show");
    setStatus("Game ended.");
    levelEl.textContent = `N = ${N}`;
  }

  function attemptClose(){
    try { window.close(); } catch(e) {}
  }

  function endGame(){
    runToken++;
    showFinalScore();
  }

  endBtn.addEventListener("click", () => {
    ensureAudio();
    endGame();
  });

  closeBtn.addEventListener("click", () => {
    ensureAudio();
    endGame();
  });

  closeFromOverlay.addEventListener("click", () => {
    attemptClose();
  });

  restartFromOverlay.addEventListener("click", () => {
    overlay.classList.remove("show");
    startGame();
  });

  function startGame(){
    ensureAudio();
    lockViewport();
    runToken++;
    phase = "idle";
    N = 2;
    maxNThisSession = 2;
    setLevel();
    clearBoard();
    setStatus("Starting…");
    sleep(120).then(() => runRound(runToken));
  }

  startBtn.addEventListener("click", () => startGame());

})();
</script>

</body>
</html>
