<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Spatial Memory Trainer</title>

<style>
  :root{
    --bg:#0b1020;
    --panel:#111a33;
    --arena:#101a35;
    --text:#eef;
    --muted:#b7c0ee;

    --flash1:#1f2f66;
    --flash2:#0d1633;

    /* chosen by dropdown */
    --bgA:#1a2a5a;
    --bgB:#0b1020;

    --gameA: rgba(16,26,53,0.78);
    --gameB: rgba(16,26,53,0.78);
  }

  html, body{ height:100%; width:100%; overflow:hidden; }
  body{
    margin:0;
    background: radial-gradient(1000px 700px at 50% 10%, var(--bgA), var(--bgB));
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    display:grid;
    grid-template-rows:auto 1fr;
    height:100dvh;
    position:fixed;
    inset:0;
    overflow:hidden;
  }

  header{
    padding:10px 14px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    background: rgba(17,26,51,0.88);
    border-bottom: 1px solid rgba(255,255,255,0.10);
    gap:12px;
    flex-wrap:wrap;
  }

  #status{ color:var(--muted); font-size:14px; }
  #level { font-size:14px; }
  #controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

  button{
    padding:7px 12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.10);
    color:var(--text);
    cursor:pointer;
  }
  button:hover{ background: rgba(255,255,255,0.16); }

  select{
    padding:7px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.10);
    color:var(--text);
    outline:none;
  }
  option{ color:#111; }

  #closeBtn{
    font-size:16px;
    line-height:1;
    padding:7px 12px;
  }

  #playPanel{
    display:grid;
    place-items:center;
    padding:12px;
    padding-bottom: calc(12px + env(safe-area-inset-bottom));
  }

  #game{
    touch-action: none;
    position:relative;
    width:min(900px, 96vw);
    height:min(600px, 72vh);
    background: radial-gradient(900px 650px at 50% 35%, var(--gameA), var(--gameB));
    border:1px solid rgba(255,255,255,0.12);
    border-radius:18px;
    overflow:hidden;
    box-shadow: 0 20px 70px rgba(0,0,0,0.35);
    transition: background 160ms ease, box-shadow 220ms ease;
  }

  /* When photo background is active, make the play panel transparent so the photo shows through */
  #playPanel.photoBgActive #game{
    background: transparent !important;
  }
  #playPanel.photoBgActive #game.flashA{ background: rgba(31,47,102,0.32) !important; }
  #playPanel.photoBgActive #game.flashB{ background: rgba(13,22,51,0.38) !important; }
  #playPanel.photoBgActive .circle{
    transition: left 120ms ease, top 120ms ease, width 120ms ease, height 120ms ease, transform 120ms ease; opacity: 0.90; }


  #game.flashA{ background: rgba(31,47,102,0.88); }
  #game.flashB{ background: rgba(13,22,51,0.92); }

  /* Gold success/failure transition */
  #game.goldA{
    background: radial-gradient(900px 650px at 50% 35%,
      rgba(255,236,170,0.88),
      rgba(255,196,80,0.58),
      rgba(16,26,53,0.92));
  }
  #game.goldB{
    background: radial-gradient(900px 650px at 50% 35%,
      rgba(255,250,210,0.95),
      rgba(255,215,120,0.66),
      rgba(16,26,53,0.94));
  }
  #game.goldGlow{
    box-shadow:
      0 0 0 3px rgba(255,215,120,0.35),
      0 0 45px rgba(255,215,120,0.95),
      0 0 110px rgba(255,215,120,0.60),
      0 0 180px rgba(255,215,120,0.28),
      0 20px 70px rgba(0,0,0,0.35);
  }

  /* Central arena (invisible boundary for placement) */
  #arena{
    position:absolute;
    left:15%;
    top:20%;
    width:70%;
    height:60%;
    pointer-events:none;
  }

  .circle{
    transition: left 120ms ease, top 120ms ease, width 120ms ease, height 120ms ease, transform 120ms ease;
    box-sizing: border-box;
    box-sizing: border-box;
    position:absolute;
    border-radius:50%;
    border:2px solid rgba(255,255,255,0.22);
    box-shadow: 0 10px 25px rgba(0,0,0,0.25);
    opacity:0;
    transform: scale(0.96);
    transition: opacity 160ms ease, transform 160ms ease, left 160ms ease, top 160ms ease, width 160ms ease, height 160ms ease;
    -webkit-tap-highlight-color: transparent;
    user-select:none;
    touch-action: manipulation;
    overscroll-behavior: none;
  }
  .circle.visible{ opacity:1; transform: scale(1); }

  /* Calmer encoding: keep previously shown circles lightly visible */
  .circle.dim{
    opacity: 0.35 !important;
    transform: scale(0.985);
    filter: saturate(0.95);
  }
  .circle.active{
    opacity: 1 !important;
    transform: scale(1.03);
    border-color: rgba(255,255,255,0.34);
    box-shadow:
      0 0 0 3px rgba(255,255,255,0.14),
      0 10px 25px rgba(0,0,0,0.25);
  }

  .circle.wrong{
    border-color: rgba(255,120,120,0.95);
    box-shadow: 0 0 0 4px rgba(255,120,120,0.18), 0 10px 25px rgba(0,0,0,0.25);
  }
  .circle.glow{
    border-color: rgba(255,215,120,0.98);
    box-shadow:
      0 0 0 4px rgba(255,215,120,0.28),
      0 0 22px rgba(255,215,120,0.90),
      0 0 46px rgba(255,215,120,0.60),
      0 10px 25px rgba(0,0,0,0.25);
    transition: box-shadow 220ms ease, border-color 220ms ease;
  }


  /* Lines layer (sequence connections) */
  #linesLayer{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    pointer-events:none;
    overflow:visible;
  }
  #linesLayer line{
    stroke: rgba(255,255,255,0.55);
    stroke-width: 2.25;
    stroke-linecap: round;
  }

  /* End screen */
  #overlay{
    z-index: 50;
    position:absolute;
    inset:0;
    background: rgba(0,0,0,0.55);
    display:none;
    align-items:center;
    justify-content:center;
    padding:18px;
  }
  #overlay.show{ display:flex; }
  #panel{
    width:min(520px, 92vw);
    background: rgba(17,26,51,0.94);
    border:1px solid rgba(255,255,255,0.14);
    border-radius:18px;
    box-shadow: 0 25px 90px rgba(0,0,0,0.55);
    padding:18px 18px 14px;
  }
  #panel h2{
    margin:0 0 8px;
    font-size:20px;
    font-weight:800;
    letter-spacing:0.2px;
  }
  #score{
    margin:10px 0 14px;
    font-size:34px;
    font-weight:900;
  }
  #panel p{
    margin:0 0 14px;
    color:var(--muted);
    line-height:1.35;
  }
  #panel .row{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    justify-content:flex-end;
  }

  /* --- v15: Primary Play button --- */
  button.primary{
    padding:10px 18px;
    font-size:16px;
    font-weight:700;
    letter-spacing:0.2px;
    border:1px solid rgba(255,255,255,0.28);
    background: rgba(255,255,255,0.12);
    box-shadow: 0 0 18px rgba(255,215,128,0.18);
    position:relative;
  }
  @keyframes softPulse{
    0%,100%{ box-shadow: 0 0 18px rgba(255,215,128,0.16); }
    50%{ box-shadow: 0 0 26px rgba(255,215,128,0.24); }
  }
  button.primary:not(:disabled){
    animation: softPulse 2.6s ease-in-out infinite;
  }

  /* --- v15: Background swatch strip --- */
  .bg-palette-wrap{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }
  .bg-label{
    color:var(--muted);
    font-size:14px;
  }
  .bg-palette{
    display:flex;
    gap:8px;
    align-items:center;
    padding:4px 6px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.06);
    max-width:min(420px, 74vw);
    overflow-x:auto;
    -webkit-overflow-scrolling: touch;
  }
  .bg-swatch{
    width:26px;
    height:26px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.22);
    box-shadow: inset 0 0 0 1px rgba(0,0,0,0.18);
    flex:0 0 auto;
    cursor:pointer;
    position:relative;
  }
  .bg-swatch[aria-selected="true"]{
    outline:2px solid rgba(255,255,255,0.85);
    outline-offset:2px;
  }


  /* --- v19: Tuning controls (Timing + Size) --- */
  .tune-wrap{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }
  .tune{
    display:flex;
    gap:8px;
    align-items:center;
    padding:4px 6px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.06);
  }
  .tune-label{
    color:var(--muted);
    font-size:14px;
    margin-right:2px;
  }
  .tune-btn{
    width:30px;
    height:30px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.18);
    background: rgba(0,0,0,0.10);
    color:var(--text);
    font-weight:700;
    line-height:1;
  }
  .tune-btn:active{ transform: scale(0.98); }
  .dots{
    display:flex;
    gap:4px;
    align-items:center;
    padding:0 2px;
  }
  .dot{
    width:7px;
    height:7px;
    border-radius:50%;
    background: rgba(255,255,255,0.18);
    box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25);
  }
  .dot.on{ background: rgba(255,255,255,0.80); }


  /* --- Miss allowance (3 dots) --- */
  .missBar{
    display:flex;
    gap:6px;
    align-items:center;
    padding:6px 10px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,0.14);
    background: rgba(255,255,255,0.06);
  }
  .missDot{
    width:10px; height:10px;
    border-radius:50%;
    background: rgba(255,255,255,0.85);
    box-shadow: 0 0 0 1px rgba(0,0,0,0.18) inset;
    opacity: 0.95;
  }
  .missDot.used{
    background: rgba(255,120,120,0.75);
    opacity: 0.55;
  }


  /* Photo background swatch button */
  .bgSwatch.photo{
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:16px;
    line-height:1;
    border-style:dashed;
    border-width:1px;
  }
  .bgSwatch.photo::after{ content:""; }
  .photoBgActive .bg-palette-wrap{ backdrop-filter: blur(2px); }


  /* Photo background: avoid cropping faces by using CONTAIN.
     Add a soft blurred "fill" behind so letterboxing looks good. */
  #playPanel.photoBgActive{
    position: relative;
    overflow: hidden;
    background-image: var(--photoUrl);
    background-size: contain;
    background-position: center center;
    background-repeat: no-repeat;
  }
  #playPanel.photoBgActive::before{
    content:"";
    position:absolute;
    inset:0;
    background-image: var(--photoUrl);
    background-size: cover;         /* fill behind (may crop, but blurred) */
    background-position: center center;
    background-repeat: no-repeat;
    filter: blur(18px) brightness(0.85);
    transform: scale(1.08);
    opacity: 0.85;
    z-index: 0;
    pointer-events:none;
  }
  #playPanel.photoBgActive > *{
    position: relative;
    z-index: 1;
  }


  background: rgba(0,0,0,0.18);
    pointer-events: none; /* allow clicks/taps to pass through to circles */
  }
  #overlay.photoMode #panel{
    background: rgba(17,26,51,0.12);
    border-color: rgba(255,255,255,0.12);
    backdrop-filter: blur(2px);
    pointer-events: none;
  }


  /* Photo overlay (foreground) */
  #photoOverlay{
    position:absolute;
    inset:0;
    display:none;
    pointer-events:none; /* let gameplay continue underneath */
    z-index: 5;
  }
  #photoOverlay.show{ display:block; }
  #photoOverlay::before{
    content:"";
    position:absolute; inset:0;
    background: rgba(0,0,0,0.18);
  }
  #photoOverlayImg{
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit: cover;
    object-position: center;
    opacity: 0.35;
    filter: saturate(1.02) contrast(1.02);
  }


  /* Ensure final score overlay covers the entire play area */
  #overlay{
    position:absolute;
    inset:0;
  }
  #overlay.show{
    display:flex;
  }
  #panel{
    max-height: calc(100% - 24px);
    overflow:auto;
  }


  #uploadBtn{
    padding: 12px 18px !important;
    min-width: 96px;
    font-weight: 800;
    letter-spacing: 0.2px;
  }


  /* Voice + Upload row */
  .voice-wrap{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
    margin-top:8px;
  }
  .tune-btn.wide{
    width:auto !important;
    min-width: 92px;
    padding: 10px 14px !important;
    font-weight: 800;
    letter-spacing: 0.2px;
  }
  .pill{
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:8px 10px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,0.14);
    background: rgba(255,255,255,0.06);
    color: var(--muted);
    font-size:14px;
  }
  button:disabled{ opacity:0.45; }
  #recBtn.recording{
    border-color: rgba(255,80,80,0.9) !important;
    box-shadow: 0 0 0 2px rgba(255,80,80,0.25);
  }


  /* Center labels on Stop/Clear */
  #stopRecBtn, #clearRecBtn, #markRecBtn{
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
  }

</style>

</head>

<body>
<header>
  <div id="controls">
    <button id="startBtn" class="primary">Play</button>
    
    <div id="missBar" class="missBar" title="Mistakes allowed (resets each round)">
      <span class="missDot"></span><span class="missDot"></span><span class="missDot"></span>
    </div>
<button id="endBtn" title="End game and show score">End</button>

    

    <div id="level"><span class="pill">N = <b id="nVal">2</b></span> <span class="pill" style="margin-left:10px;">Words: <b id="wordCount">0</b></span></div>
<div class="bg-palette-wrap" aria-label="Background">
      <span class="bg-label">Background</span>
      <div id="bgPalette" class="bg-palette" role="listbox" aria-label="Background colors"></div>

    <div class="voice-wrap" aria-label="Voice recording">
      <button id="uploadBtn" class="tune-btn wide" title="Upload photo overlay (tap) / clear (hold)">Upload</button>
      <button id="recBtn" class="tune-btn wide" title="Record voice (tap once per word as you speak)">Record</button>
      <button id="stopRecBtn" class="tune-btn" title="Stop recording" disabled>Stop</button>
      <button id="clearRecBtn" class="tune-btn" title="Clear recording" disabled>Clear</button>
<button id="markRecBtn" class="tune-btn" title="Mark word boundary (use if screen taps miss)" disabled>Mark</button>
</div>
</div>

    <div class="tune-wrap" aria-label="Training tuning">
      <div class="tune" role="group" aria-label="Timing">
        <span class="tune-label">Timing</span>
        <button class="tune-btn" id="paceMinus" aria-label="Timing down">−</button>
        <div class="dots" id="paceDots" aria-hidden="true"></div>
        <button class="tune-btn" id="pacePlus" aria-label="Timing up">+</button>
      </div>

      <div class="tune" role="group" aria-label="Circle size">
        <span class="tune-label">Size</span>
        <button class="tune-btn" id="sizeMinus" aria-label="Size down">−</button>
        <div class="dots" id="sizeDots" aria-hidden="true"></div>
        <button class="tune-btn" id="sizePlus" aria-label="Size up">+</button>
      </div>
    </div>

  </div>

  <div style="display:flex; gap:10px; align-items:center;">
    <div id="status">Press Play once. Then it runs continuously.</div>
    <button id="closeBtn" title="Close">✕</button>
  </div>
</header>

<div id="playPanel">
  <div id="game">
    <div id="arena"></div>
    <svg id="linesLayer" aria-hidden="true"></svg>

    <div id="photoOverlay" aria-hidden="true">
      <img id="photoOverlayImg" alt="Uploaded photo" />
    </div>


    <div id="overlay" role="dialog" aria-modal="true">
      <div id="panel">
        <h2>Final Score</h2>
<div id="score">N = 2</div>
        <p>
          This is the <b>highest N</b> you reached in this session.
          
        </p>
        <div class="row">
          <button id="restartFromOverlay">Play Again</button>
          <button id="closeFromOverlay">Close</button>
        </div>

        <div style="margin-top:12px; padding-top:10px; border-top:1px solid rgba(255,255,255,0.14);">
          <div style="color:var(--muted); font-size:13px; margin-bottom:8px;">
            If you enjoy this trainer, please consider supporting development:
          </div>
          <a href="https://www.paypal.com/paypalme/ConstantinosRagazas" target="_blank" rel="noopener"
             style="display:inline-flex; align-items:center; gap:8px; padding:10px 12px; border-radius:12px;
                    border:1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.08); color:var(--text);
                    text-decoration:none; font-weight:800;">
            Donate via PayPal
          </a>
        </div>
      </div>
    </div>

  </div>
</div>


  <input id="bgFileInput" type="file" accept="image/*" style="display:none" />
<script>
(() => {
  const game   = document.getElementById("game");
  const arena  = document.getElementById("arena");
  const startBtn = document.getElementById("startBtn");
  

  // ---- Forgiving misses (kid-friendly) ----
  const MISS_LIMIT = 3;     // per round
  let missesUsed = 0;
  const missBar = document.getElementById("missBar");
  function renderMisses(){
    if(!missBar) return;
    const dots = [...missBar.querySelectorAll(".missDot")];
    dots.forEach((d,i)=> d.classList.toggle("used", i < missesUsed));
  }

  function playFail(){
    // distinct fail sound (short descending buzz), safe if audio blocked
    try{
      if(!audioCtx) return;
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sawtooth";
      o.frequency.setValueAtTime(240, t0);
      o.frequency.exponentialRampToValueAtTime(120, t0 + 0.18);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.20, t0 + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t0); o.stop(t0 + 0.24);
    }catch(e){}
  }

  function playShimmerMelody(){
    // Brief, pleasant 3-note sparkle to accompany the gold shimmer cue.
    // Safe if audio is blocked; uses the existing AudioContext.
    try{
      const ctx = ensureAudio();
    // audible confirmation (very short)
    try{ playToneForIndex(0, 90); }catch(e){}
      const now = ctx.currentTime;

      const notes = [659.25, 783.99, 987.77]; // E5, G5, B5
      const dur = 0.11;
      const gap = 0.03;

      notes.forEach((f, i) => {
        const t0 = now + i*(dur+gap);
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "triangle";
        o.frequency.setValueAtTime(f, t0);

        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(0.18, t0 + 0.015);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        o.connect(g); g.connect(ctx.destination);
        o.start(t0);
        o.stop(t0 + dur + 0.02);
      });
    }catch(e){}
  }

const endBtn = document.getElementById("endBtn");
  const closeBtn = document.getElementById("closeBtn");
  const statusEl = document.getElementById("status");
  const levelEl  = document.getElementById("level");

  // --- v19: Tuning module (no numbers; dot preview) ---
  const paceMinus = document.getElementById("paceMinus");
  const pacePlus  = document.getElementById("pacePlus");
  const sizeMinus = document.getElementById("sizeMinus");
  const sizePlus  = document.getElementById("sizePlus");
  const paceDots  = document.getElementById("paceDots");
  const sizeDots  = document.getElementById("sizeDots");

  // Levels 1..5 (3 is default)
  let paceLevel = 3;
  let sizeLevel = 3;

  function makeDots(el){
    if(!el) return;
    el.innerHTML = "";
    for(let i=0;i<5;i++){
      const d=document.createElement("div");
      d.className="dot";
      el.appendChild(d);
    }
  }
  makeDots(paceDots);
  makeDots(sizeDots);

  function setDots(el, level){
    if(!el) return;
    const kids=[...el.children];
    kids.forEach((d,i)=> d.classList.toggle("on", i < level));
  }

  function applyPace(){
    // paceLevel 1 fastest -> 5 slowest
    // More noticeable multipliers: 0.60, 0.80, 1.00, 1.35, 1.75
    const mult = [0.60, 0.80, 1.00, 1.35, 1.75][paceLevel-1];
    SHOW_MS = Math.round(700 * mult);
    GAP_MS  = Math.round(300 * mult);
    setDots(paceDots, paceLevel);
  }

  function applySize(){
    // sizeLevel 1 small -> 5 large
    RECALL_RADIUS = [16, 20, 24, 30, 36][sizeLevel-1];
    setDots(sizeDots, sizeLevel);
  }

  function initTuning(){
    applyPace(); applySize();
    if(paceMinus) paceMinus.addEventListener("click", ()=>{ paceLevel=Math.max(1, paceLevel-1); applyPace(); });
    if(pacePlus)  pacePlus .addEventListener("click", ()=>{ paceLevel=Math.min(5, paceLevel+1); applyPace(); });
    if(sizeMinus) sizeMinus.addEventListener("click", ()=>{ sizeLevel=Math.max(1, sizeLevel-1); applySize(); });
    if(sizePlus)  sizePlus .addEventListener("click", ()=>{ sizeLevel=Math.min(5, sizeLevel+1); applySize(); });
  }

  const overlay = document.getElementById("overlay");
  const scoreEl = document.getElementById("score");
  const restartFromOverlay = document.getElementById("restartFromOverlay");
  const closeFromOverlay = document.getElementById("closeFromOverlay");

  const linesLayer = document.getElementById("linesLayer");

  function clearLines(){
    while (linesLayer.firstChild) linesLayer.removeChild(linesLayer.firstChild);
  }

  function syncLinesViewport(){
    // Keep SVG coordinate system in the same pixel space as the #game box.
    const r = game.getBoundingClientRect();
    linesLayer.setAttribute("viewBox", `0 0 ${r.width} ${r.height}`);
    linesLayer.setAttribute("preserveAspectRatio", "none");
  }

  function drawLine(from, to){
    // from/to are in game-local coordinates (same as circle cx/cy).
    syncLinesViewport();
    const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
    ln.setAttribute("x1", from.cx);
    ln.setAttribute("y1", from.cy);
    ln.setAttribute("x2", to.cx);
    ln.setAttribute("y2", to.cy);
    ln.setAttribute("opacity", "0.85");
    linesLayer.appendChild(ln);
  }


  // ---------- Tuning knobs ----------
  const MIN_N = 2;
  const MAX_N = 30;

  let SHOW_MS = 650;
  let GAP_MS  = 250;

  const SHOW_RADIUS_MIN = 34;
  const SHOW_RADIUS_MAX = 54;

  let RECALL_RADIUS   = 22;    // adjustable size for recall
  const PADDING_BETWEEN = 12;    // non-overlap margin

  const BETWEEN_ROUNDS_MS = 900; // pause after success/fail

  // pre-round cue
  const PRE_ROUND_DELAY_MS = 650;
  const FLICKER_COUNT = 2;
  const FLICKER_STEP_MS = 90;

  // ---------- Distinct primary-ish colors ----------
  const COLOR_PALETTE = [
    { name:"red",     h:  0,  s:92, l:58 },
    { name:"blue",    h:210,  s:92, l:58 },
    { name:"yellow",  h: 52,  s:95, l:55 },
    { name:"green",   h:120,  s:85, l:48 },
    { name:"magenta", h:305,  s:88, l:58 },
    { name:"cyan",    h:185,  s:92, l:55 },
    { name:"orange",  h: 28,  s:95, l:56 },
    { name:"violet",  h:260,  s:88, l:60 },
    { name:"lime",    h: 85,  s:92, l:52 },
    { name:"pink",    h:330,  s:90, l:60 },
    { name:"teal",    h:165,  s:80, l:48 },
    { name:"amber",   h: 42,  s:95, l:56 },
  ];

  // ---------- Bold, distinct tones (fixed mapping) ----------
  const NOTE_FREQS = [
    220.00, 261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 659.25,
    783.99, 880.00, 987.77, 1046.50
  ];
  const WAVEFORMS = ["sine", "triangle", "square", "sawtooth"];

  let audioCtx = null;
  function ensureAudio() {
    audioCtx ??= new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();
    return audioCtx;
  }

  // iOS audio unlock (first user gesture)
  window.addEventListener("touchstart", () => { try{ ensureAudio(); }catch(e){} }, { once:true, passive:true });


  function playToneForIndex(idx, ms=140) {
    const ctx = ensureAudio();
    const o = ctx.createOscillator();
    const g = ctx.createGain();

    o.frequency.value = NOTE_FREQS[idx % NOTE_FREQS.length];
    o.type = WAVEFORMS[idx % WAVEFORMS.length];

    const now = ctx.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.22, now + 0.008);
    g.gain.exponentialRampToValueAtTime(0.0001, now + ms/1000);

    o.detune.setValueAtTime(0, now);
    o.detune.linearRampToValueAtTime(6, now + 0.03);
    o.detune.linearRampToValueAtTime(0, now + 0.09);

    o.connect(g); g.connect(ctx.destination);
    o.start(now);
    o.stop(now + ms/1000 + 0.03);
  }

  // ---------- Helpers ----------
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));
  const rand  = (a,b) => Math.random()*(b-a)+a;
  const clamp = (v,lo,hi) => Math.max(lo, Math.min(hi, v));
  const shuffle = (arr) => {
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  };
  const dist  = (a,b) => Math.hypot(a.cx-b.cx, a.cy-b.cy);

  function setStatus(s){ statusEl.textContent = s; }
  function setLevel(){ const nEl=document.getElementById("nVal"); if(nEl) nEl.textContent = String(N); }

  // ---------- iOS / anti-jump ----------
  function lockViewport(){
    document.documentElement.style.overflow = "hidden";
    document.body.style.overflow = "hidden";
    document.body.style.position = "fixed";
    document.body.style.inset = "0";
    document.body.style.width = "100%";
    window.scrollTo(0,0);
  }
  function unlockViewport(){
    document.documentElement.style.overflow = "hidden";
    document.body.style.overflow = "hidden";
  }

  window.addEventListener("resize", () => {
    if (phase !== "idle") window.scrollTo(0,0);
  });

  const _lockToTop = () => { try { window.scrollTo(0,0); } catch(e){} };

  window.addEventListener("scroll", () => {
    if (phase !== "idle") _lockToTop();
  }, { passive:true });

  if (window.visualViewport) {
    window.visualViewport.addEventListener("resize", () => {
      if (phase !== "idle") _lockToTop();
    });
    window.visualViewport.addEventListener("scroll", () => {
      if (phase !== "idle") _lockToTop();
    });
  }

  document.addEventListener("touchmove", (e) => {
    if (phase !== "idle") e.preventDefault();
  }, { passive:false });

  const _isInteractive = (t) => !!(t && (t.closest?.(".circle") || t.closest?.("button") || t.closest?.("select")));

  document.addEventListener("touchstart", (e) => {
    if (typeof voice !== "undefined" && voice && voice.recording) return;
    if (phase !== "idle" && !_isInteractive(e.target)) e.preventDefault();
  }, { passive:false });

  document.addEventListener("touchend", (e) => {
    if (typeof voice !== "undefined" && voice && voice.recording) return;
    if (phase !== "idle" && !_isInteractive(e.target)) e.preventDefault();
  }, { passive:false });

  // ---------- Background palette (modular) ----------
  const BACKGROUND_THEMES = {
    deepBlue: { name:"Deep Blue", swatch:"#1a2a5a", bgA:"#1a2a5a", bgB:"#0b1020", gameA:"rgba(16,26,53,0.78)", gameB:"rgba(16,26,53,0.78)" },
    charcoal:{ name:"Charcoal", swatch:"#2a2a2a", bgA:"#2a2a2a", bgB:"#0b0b0b", gameA:"rgba(28,28,28,0.82)", gameB:"rgba(18,18,18,0.82)" },
    forest:  { name:"Forest",   swatch:"#1b4a3a", bgA:"#1b4a3a", bgB:"#07120e", gameA:"rgba(12,34,26,0.82)", gameB:"rgba(12,34,26,0.82)" },
    plum:    { name:"Plum",     swatch:"#4a1b4a", bgA:"#4a1b4a", bgB:"#0f0610", gameA:"rgba(34,12,35,0.82)", gameB:"rgba(34,12,35,0.82)" },
    sand:    { name:"Sand",     swatch:"#c9b07a", bgA:"#c9b07a", bgB:"#2c2416", gameA:"rgba(44,36,22,0.78)", gameB:"rgba(44,36,22,0.78)" },
  };

  function applyBackgroundTheme(key){
    const t = BACKGROUND_THEMES[key] || BACKGROUND_THEMES.deepBlue;
    const r = document.documentElement.style;
    r.setProperty("--bgA", t.bgA);
    r.setProperty("--bgB", t.bgB);
    r.setProperty("--gameA", t.gameA);
    r.setProperty("--gameB", t.gameB);
  }

  // Module: renders swatches and manages selection state
  
  // ---- Upload photo as FOREGROUND overlay (covers play area, game continues underneath) ----
  const bgFileInput = document.getElementById("bgFileInput");
  const uploadBtn = document.getElementById("uploadBtn");
  const photoOverlay = document.getElementById("photoOverlay");
  const photoOverlayImg = document.getElementById("photoOverlayImg");

  function showPhotoOverlay(dataUrl){
    if(!photoOverlay || !photoOverlayImg) return;
    photoOverlayImg.src = dataUrl;
    photoOverlay.classList.add("show");
    photoOverlay.setAttribute("aria-hidden","false");
    setStatus("Photo overlay on. Play continues underneath.");
  }

  function clearPhotoOverlay(){
    if(!photoOverlay || !photoOverlayImg) return;
    photoOverlayImg.src = "";
    photoOverlay.classList.remove("show");
    photoOverlay.setAttribute("aria-hidden","true");
    setStatus("Photo overlay cleared.");
  }

  function openPhotoPicker(){
    if(!bgFileInput) return;
    bgFileInput.click();
  }

  if(uploadBtn){
    // iOS-safe: direct user gesture -> file picker
    uploadBtn.addEventListener("click", (e)=>{ e.preventDefault(); openPhotoPicker(); }, {passive:false});
    uploadBtn.addEventListener("touchend", (e)=>{ e.preventDefault(); openPhotoPicker(); }, {passive:false});

    // Long-press (0.6s) clears
    let t=null;
    const start=()=>{ if(t) clearTimeout(t); t=setTimeout(()=>{ clearPhotoOverlay(); }, 600); };
    const cancel=()=>{ if(t) clearTimeout(t); t=null; };
    uploadBtn.addEventListener("touchstart", start, {passive:true});
    uploadBtn.addEventListener("touchmove", cancel, {passive:true});
    uploadBtn.addEventListener("touchcancel", cancel, {passive:true});
    uploadBtn.addEventListener("pointerdown", start, {passive:true});
    uploadBtn.addEventListener("pointerup", cancel, {passive:true});
    uploadBtn.addEventListener("pointercancel", cancel, {passive:true});
  }

  if(bgFileInput){
    bgFileInput.addEventListener("change", (e)=>{
      const file = e.target.files && e.target.files[0];
      if(!file) return;
      if(!file.type || !file.type.startsWith("image/")) return;
      const reader = new FileReader();
      reader.onload = ()=>{
        if(typeof reader.result === "string") showPhotoOverlay(reader.result);
      };
      reader.readAsDataURL(file);
      bgFileInput.value = "";
    });
  }


  // ---- Voice recording (tap once per word) + word playback on sequence and recall ----
  const recBtn = document.getElementById("recBtn");
  const stopRecBtn = document.getElementById("stopRecBtn");
  const clearRecBtn = document.getElementById("clearRecBtn");
  const markRecBtn  = document.getElementById("markRecBtn");
  const wordCountEl = document.getElementById("wordCount");

  const voice = {
    wordIndex:0,       // how many words have been spoken in current recall
    recording:false,
    mediaRecorder:null,
    stream:null,
    chunks:[],
    markers:[],        // ms offsets from start
    startedAt:0,
    audioBuffer:null,  // decoded AudioBuffer
    segments:[]        // [{start,end}] seconds, length = words
  };

  // Serialize speech so timing stays in sync
  let speechQueue = Promise.resolve();
  let lastMarkTs = 0;

  let voiceBusy = false; // prevents processing next click before voice finishes

  function enqueueSpeech(fn){
    speechQueue = speechQueue.then(fn, fn);
    return speechQueue;
  }

    function updateWordCountUI(){
    if(!wordCountEl) return;
    const total = (voice && Array.isArray(voice.segments)) ? voice.segments.length : 0;
    const spoken = (voice && typeof voice.wordIndex === "number") ? voice.wordIndex : 0;
    if(voice && voice.recording){
      wordCountEl.textContent = String(total);
    } else {
      if(total > 0) wordCountEl.textContent = `${spoken}/${total}`;
      else wordCountEl.textContent = "0";
    }
  }

  function setWordCount(n){
    // backward compatible: set total (recorded) count directly
    if(!wordCountEl) return;
    wordCountEl.textContent = String(n||0);
  }

  function pickMime(){
    const mimes = ["audio/mp4","audio/webm;codecs=opus","audio/webm","audio/ogg;codecs=opus"];
    for(const m of mimes){
      try{ if(window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) return m; }catch(e){}
    }
    return "";
  }

  async function decodeAndBuildSegments(blob){
    const ctx = ensureAudio();
    if(ctx.state === "suspended"){ try{ await ctx.resume(); }catch(e){} }
    const arr = await blob.arrayBuffer();
    const buf = await ctx.decodeAudioData(arr.slice(0));
    voice.audioBuffer = buf;

    const durMs = buf.duration * 1000;
    const marks = voice.markers
      .slice()
      .filter(ms => ms >= 0 && ms <= durMs)
      .sort((a,b)=>a-b);

    const segs = [];
    let prev = 0;
    for(const ms of marks){
      const s = prev/1000, e = ms/1000;
      if(e - s > 0.06) segs.push({start:s, end:e});
      prev = ms;
    }
    const lastS = prev/1000;
    if(buf.duration - lastS > 0.06) segs.push({start:lastS, end: buf.duration});

    voice.segments = segs.length ? segs : [{start:0, end: buf.duration}];
    setWordCount(voice.segments.length);
  }

  async function startRecording(){
    if(!navigator.mediaDevices?.getUserMedia || !window.MediaRecorder){
      setStatus("Recording not supported on this browser.");
      return;
    }
    try{
      ensureAudio();
      const stream = await navigator.mediaDevices.getUserMedia({audio:true});
      voice.stream = stream;
      voice.chunks = [];
      voice.markers = [];
      voice.audioBuffer = null;
      voice.segments = [];
      setWordCount(0);
    voice.wordIndex = 0;
    updateWordCountUI();

      const mime = pickMime();
      const mr = new MediaRecorder(stream, mime ? {mimeType:mime} : undefined);
      voice.mediaRecorder = mr;

      mr.ondataavailable = (e)=>{ if(e.data && e.data.size) voice.chunks.push(e.data); };
      mr.onstop = async ()=>{
        try{ stream.getTracks().forEach(t=>t.stop()); }catch(e){}
        const blob = new Blob(voice.chunks, { type: mr.mimeType || mime || "audio/webm" });
        try{
          await decodeAndBuildSegments(blob);
          clearRecBtn.disabled = false;
          setStatus(`Recorded ${voice.segments.length} word(s).`);
        }catch(e){
          setStatus("Recorded, but could not decode audio on this device.");
        }
      };

      voice.startedAt = performance.now();
      voice.recording = true;
      mr.start();

      recBtn?.classList.add("recording");
      recBtn.disabled = true;
      stopRecBtn.disabled = false;
      clearRecBtn.disabled = true;
      if(markRecBtn) markRecBtn.disabled = false;

      setStatus("Recording… tap once per word as you speak.");
    }catch(e){
      setStatus("Mic permission denied/unavailable.");
    }
  }

  function stopRecording(){
    if(!isRecordingActive()) return;
    voice.recording = false;
    updateWordCountUI();
    try{ voice.mediaRecorder?.stop(); }catch(e){}
    recBtn?.classList.remove("recording");
    recBtn.disabled = false;
    stopRecBtn.disabled = true;
    if(markRecBtn) markRecBtn.disabled = true;
  }

  function clearRecording(){
    voice.recording = false;
    try{ voice.stream?.getTracks().forEach(t=>t.stop()); }catch(e){}
    voice.stream = null;
    voice.mediaRecorder = null;
    voice.chunks = [];
    voice.markers = [];
    voice.audioBuffer = null;
    voice.segments = [];
    setWordCount(0);
    updateWordCountUI();
    clearRecBtn.disabled = true;
    if(markRecBtn) markRecBtn.disabled = true;
    setStatus("Voice cleared.");
  }

  function markWordBoundary(){
    const now = Date.now();
    if (now - lastMarkTs < 250) return; // debounce double-fired tap
    lastMarkTs = now;
    if(!isRecordingActive()) return;
    const ms = performance.now() - voice.startedAt;
    voice.markers.push(ms);
    setWordCount(voice.markers.length);
      updateWordCountUI();
}

  const WORD_PAD_BEFORE_MS = 90;
  const WORD_PAD_AFTER_MS  = 140;

  function hasVoiceWords(){
    return !!(voice.audioBuffer && voice.segments && voice.segments.length);
  }
  async function _playWordNow(index){
    // Plays the slice for the given word index.
    // Returns true if a word was played, false otherwise.
    if(!hasVoiceWords()) return false;

    const seg = voice.segments[index % voice.segments.length];
    const ctx = ensureAudio();
    if(ctx.state === "suspended"){ try{ await ctx.resume(); }catch(e){} }

    const dur = Math.max(0.03, seg.end - seg.start);

    // small silence before each word
    await sleep(WORD_PAD_BEFORE_MS);

    await new Promise((resolve) => {
      try{
        const src = ctx.createBufferSource();
        src.buffer = voice.audioBuffer;
        src.connect(ctx.destination);

        let doneCalled = false;
        const done = () => {
          if(doneCalled) return;
          doneCalled = true;
          resolve();
        };

        src.onended = done;

        const now = ctx.currentTime;
        try{
          src.start(now, seg.start, dur);
        }catch(e){
          // fallback: start without duration then stop after dur
          try{
            src.start(now, seg.start);
            setTimeout(()=>{ try{ src.stop(); }catch(_e){} }, Math.ceil(dur*1000));
          }catch(_e){}
  }

  async function playWord(index){
    return enqueueSpeech(() => _playWordNow(index));
  }

        // safety timeout in case onended doesn't fire
        setTimeout(done, Math.ceil(dur*1000) + 80);
      }catch(e){
        resolve();
      }
    });

    // small silence after each word
    await sleep(WORD_PAD_AFTER_MS);
    return true;
  }

  function playWordInstant(index){
    if(!hasVoiceWords()) return;
    const seg = voice.segments[index % voice.segments.length];
    const ctx = ensureAudio();
    const dur = Math.max(0.03, seg.end - seg.start);
    try{
      const src = ctx.createBufferSource();
      src.buffer = voice.audioBuffer;
      src.connect(ctx.destination);
      const now = ctx.currentTime;
      try{
        src.start(now, seg.start, dur);
      }catch(e){
        try{
          src.start(now, seg.start);
          setTimeout(()=>{ try{ src.stop(); }catch(_e){} }, Math.ceil(dur*1000));
        }catch(_e){}
      }
    }catch(e){}
  }


  recBtn?.addEventListener("click", startRecording);
  stopRecBtn?.addEventListener("click", stopRecording);
  clearRecBtn?.addEventListener("click", clearRecording);
  markRecBtn?.addEventListener("click", (e)=>{ e.preventDefault(); if(isRecordingActive()) markWordBoundary(); });

    // Reliable word delimiting on iOS: use pointerdown/touchend (click can be suppressed by preventDefault).
  function isRecordingActive(){
    // Record tapped and Stop not yet tapped
    return !!(voice && voice.recording && stopRecBtn && !stopRecBtn.disabled);
  }

  function shouldIgnoreMarkTarget(t){
    return !!(t && (t.closest?.("button, select, a, input") || t.closest?.(".circle") || t.closest?.("#overlay")));
  }
  function tryMarkFromEvent(e){
    if(!isRecordingActive()) return;
    const t = e.target;
    if(shouldIgnoreMarkTarget(t)) return;
    markWordBoundary();
  }
  document.addEventListener("pointerdown", (e)=>{ tryMarkFromEvent(e); }, {capture:true});
  document.addEventListener("touchend", (e)=>{ tryMarkFromEvent(e); }, {capture:true, passive:false});
  game.addEventListener("pointerup", (e)=>{ tryMarkFromEvent(e); }, {capture:true});
  game.addEventListener("touchend", (e)=>{ tryMarkFromEvent(e); }, {capture:true, passive:false});
  // Also attach to game area directly (more reliable on iOS)
  game.addEventListener("pointerdown", (e)=>{ tryMarkFromEvent(e); }, {capture:true});
  game.addEventListener("touchend", (e)=>{ tryMarkFromEvent(e); }, {capture:true, passive:false});


function initBackgroundPalette(opts){
    const {
      containerId = "bgPalette",
      defaultKey = "deepBlue",
      storageKey = "smt_bg_theme",
      onChange = () => {}
    } = (opts || {});

    const container = document.getElementById(containerId);
    if(!container) return { setTheme: applyBackgroundTheme };

    const keys = Object.keys(BACKGROUND_THEMES);

    function setSelected(key){
      [...container.querySelectorAll(".bg-swatch")].forEach(el=>{
        el.setAttribute("aria-selected", el.dataset.key === key ? "true" : "false");
      });
    }

    function setTheme(key){
      applyBackgroundTheme(key);
      setSelected(key);
      try{ localStorage.setItem(storageKey, key); }catch(e){}
      onChange(key);
    }

    // render
    container.innerHTML = "";
    keys.forEach((key)=>{
      const t = BACKGROUND_THEMES[key];
      const sw = document.createElement("button");
      sw.type = "button";
      sw.className = "bg-swatch";
      sw.title = t.name;
      sw.setAttribute("aria-selected", "false");
      sw.dataset.key = key;
      sw.style.background = t.swatch;
      sw.addEventListener("click", ()=> setTheme(key));
      container.appendChild(sw);
    });

    // initial selection (restore if possible)
    let initial = defaultKey;
    try{
      const saved = localStorage.getItem(storageKey);
      if(saved && BACKGROUND_THEMES[saved]) initial = saved;
    }catch(e){}
    setTheme(initial);
  return { setTheme };
  }

  initBackgroundPalette({ defaultKey: "deepBlue" });
  initTuning();

  // ---------- Gold transition ----------
  async function goldTransition(token){
    // Calm between-round cue: brief warm glow without flicker.
    if (token !== runToken) return;
    
    playShimmerMelody();
game.classList.add("goldGlow");
    game.classList.add("goldB");
    await sleep(260);
    game.classList.remove("goldB");
    game.classList.remove("goldGlow");
  }

  async function preRoundCue(token) {
    // Calm start: no screen flicker; just a short settle pause.
    await sleep(PRE_ROUND_DELAY_MS);
  }

  // ---------- Game state ----------
  let N = 2;
  let phase = "idle";
  let recallInputLocked = false; // idle | showing | recall | transition | ended
  let expectedIndex = 0;

  let circles = [];
  let ROUND_RADIUS = null; // locked per round to prevent size-dial drift
  let runToken = 0;

  let maxNThisSession = 2;

  function clearBoard() {
    circles.forEach(c => c.el?.remove());
    circles = [];
    expectedIndex = 0;
    clearLines();
  }

  function arenaRectInGameCoords() {
    const g = game.getBoundingClientRect();
    const a = arena.getBoundingClientRect();
    return {
      left: a.left - g.left,
      top:  a.top  - g.top,
      width: a.width,
      height: a.height
    };
  }

  function makeCircleElement(c) {
    const el = document.createElement("div");
    el.className="circle";

    const {h,s,l} = c.color;
    el.style.background = `radial-gradient(circle at 30% 30%,
      rgba(255,255,255,0.55),
      hsl(${h} ${s}% ${l}%))`;

    el.addEventListener("pointerdown", async (e) => {
      if (phase !== "recall") return;
      if (recallInputLocked) { e.preventDefault(); return; }
      recallInputLocked = true;

      handleClick(c);
      // allow next input after this click is processed
      recallInputLocked = false;
      e.preventDefault();
    });

    game.appendChild(el);
    c.el = el;
  }

  function setCircleGeometry(c, r) {
    c.el.style.width  = `${2*r}px`;
    c.el.style.height = `${2*r}px`;
    c.el.style.left   = `${c.cx - r}px`;
    c.el.style.top    = `${c.cy - r}px`;
  }

  function nonOverlappingPlacement(n) {
    const ar = arenaRectInGameCoords();

    // Place using final fixed radius (Size dial) so recall circles never overlap.
    // Pop/show circles may overlap; that's OK.
    const R = (ROUND_RADIUS ?? RECALL_RADIUS);
    const centers = [];

    const BUILD_ATTEMPTS = 80;
    const MAX_TRIES_PER_CIRCLE = 1600;

    for (let attempt = 0; attempt < BUILD_ATTEMPTS; attempt++) {
      centers.length = 0;
      let ok = true;

      for (let i = 0; i < n; i++) {
        let placed = false;

        for (let t = 0; t < MAX_TRIES_PER_CIRCLE; t++) {
          const cx = rand(ar.left + R, ar.left + ar.width  - R);
          const cy = rand(ar.top  + R, ar.top  + ar.height - R);

          let valid = true;
          for (let c of centers) {
            const D = Math.hypot(cx - c.cx, cy - c.cy);
            if (D <= 2 * R) { valid = false; break; }
          }

          if (valid) {
            centers.push({ cx, cy });
            placed = true;
            break;
          }
        }

        if (!placed) { ok = false; break; }
      }

      if (ok) break;
    }

    return centers.slice(0, n).map(c => ({
      cx: c.cx,
      cy: c.cy,
      rShow: rand(SHOW_RADIUS_MIN, SHOW_RADIUS_MAX)
    }));
  }

  async function runRound(token) {
    // Reset misses at the start of each round
    missesUsed = 0;
    renderMisses();

    phase = "transition";
    clearBoard();
    syncLinesViewport();
    setLevel();
    ROUND_RADIUS = RECALL_RADIUS; // lock radius for this round

    setStatus("Get ready…");
    await preRoundCue(token);
    if (token !== runToken) return;

    phase = "showing";
    setStatus(`Watch the sequence… (${N})`);

    const colorOrder = shuffle([...COLOR_PALETTE]);

    circles = nonOverlappingPlacement(N).map((pos, i) => {
      const color = colorOrder[i % colorOrder.length];
      const freq  = NOTE_FREQS[i % NOTE_FREQS.length];
      const wave  = WAVEFORMS[i % WAVEFORMS.length];
      return { ...pos, index:i, color, freq, wave, el:null };
    });

    circles.forEach(c => {
      makeCircleElement(c);
            // Animated pop: inflate past final radius, then settle
      const R = (ROUND_RADIUS ?? RECALL_RADIUS);
      setCircleGeometry(c, 0);
      c.el.classList.add("visible");
      await sleep(10);
      setCircleGeometry(c, R * 1.2);
      await sleep(90);
      setCircleGeometry(c, R);
c.el.classList.remove("wrong","visible","glow");
    });

    for (let i=0; i<N; i++) {
      if (token !== runToken) return;
      const c = circles[i];

      // Keep already-shown circles on-screen (dim), highlight current one.
      for (let j=0; j<i; j++){
        const p = circles[j];
        p.el.classList.add("visible");
        p.el.classList.remove("active");
        p.el.classList.add("dim");
      }

      // Draw the line from previous to current (center-to-center)
      if (i > 0) drawLine(circles[i-1], c);

      c.el.classList.add("visible");
      c.el.classList.remove("dim");
      c.el.classList.add("active");

      playToneForIndex(c.index, Math.min(190, Math.floor(SHOW_MS*0.30)));

      // Voice pacing: if words exist, the spoken word controls timing (with padding).
      // Otherwise use the Timing setting (SHOW_MS/GAP_MS).
      const didVoice = await playWord(i);

      if(!didVoice){
        await sleep(SHOW_MS);
      }

      // After its turn, keep it on-screen but dimmed (no popping)
      c.el.classList.remove("active");
      c.el.classList.add("dim");

      if(!didVoice){
        await sleep(GAP_MS);
      }
    }

    // NEW: erase lines before player starts clicking
    clearLines();

    // Calm transition: remove dim/active styling before recall layout
    circles.forEach(c => {
      c.el.classList.remove("active","dim");
      // hide briefly to avoid size-teleport feeling
      c.el.classList.remove("visible");
    });
    await sleep(120);

    phase = "recall";
    expectedIndex = 0;

    circles.forEach(c => {
      setCircleGeometry(c, (ROUND_RADIUS ?? RECALL_RADIUS));
      c.el.classList.add("visible");
    });

    setStatus(`Your turn: click in order (1 → ${N}).`);
  }

  async function handleClick(circleObj) {
    const i = circleObj.index;

    // Do not process next click until current word playback finishes
    if (voiceBusy) return;

    if (i === expectedIndex) {
      voiceBusy = true;
      try{
        playToneForIndex(circleObj.index, 135);

        circleObj.el.classList.add("glow");
        setTimeout(() => circleObj.el?.classList.remove("glow"), 160);

        // Speak ONLY on the correct click, and wait for it to finish
        try{
          const didVoice = await playWord(circleObj.index);
          if(!didVoice){
            // no recorded words: tiny pause so UI still feels paced
            await sleep(60);
          }
        }catch(e){
          // ignore voice errors but keep pacing consistent
          await sleep(60);
        }

        // Now remove the circle (after voice completes)
        circleObj.el?.remove();

        expectedIndex++;
        // Update spoken word counter and UI
        if(voice) voice.wordIndex = expectedIndex;
        try{ updateWordCountUI(); }catch(e){}

        if (expectedIndex >= N) onSuccess();
        else setStatus(`Good! Next: ${expectedIndex + 1} of ${N}.`);
      } finally {
        voiceBusy = false;
      }
    } else {
      // Wrong click: allow up to MISS_LIMIT misses per round (do not end immediately)
      playFail();
      missesUsed = Math.min(MISS_LIMIT, missesUsed + 1);
      renderMisses();

      circleObj.el.classList.add("wrong");
      setTimeout(() => circleObj.el?.classList.remove("wrong"), 260);

      const remaining = MISS_LIMIT - missesUsed;
      if (remaining > 0) {
        setStatus(`Almost! Try again. ${remaining} ${remaining === 1 ? "chance" : "chances"} left.`);
      } else {
        // Out of chances => end round as a fail
        onFail();
      }
    }
  }

  async function onSuccess() {
    phase = "transition";
    maxNThisSession = Math.max(maxNThisSession, N);
    setStatus(`✅ Success! Next round…`);
    await goldTransition(runToken);
    N = clamp(N + 1, MIN_N, MAX_N);
    await sleep(BETWEEN_ROUNDS_MS);
    if (phase !== "transition") return;
    await runRound(runToken);
  }

  async function onFailure() {
    phase = "transition";
    maxNThisSession = Math.max(maxNThisSession, N);
    setStatus(`❌ Wrong order. Adjusting…`);
    await goldTransition(runToken);
    N = clamp(N - 1, MIN_N, MAX_N);
    await sleep(BETWEEN_ROUNDS_MS);
    if (phase !== "transition") return;
    await runRound(runToken);
  }

  function showFinalScore(){
    phase = "ended";
    clearBoard();
    scoreEl.textContent = `N = ${maxNThisSession}`;
    overlay.classList.add("show");
    setStatus("Game ended.");
    setLevel();
  }

  function attemptClose(){
    try { window.close(); } catch(e) {}
  }

  function endGame(){
    runToken++;
    showFinalScore();
  }

  endBtn.addEventListener("click", () => {
    ensureAudio();
    endGame();
  });

  closeBtn.addEventListener("click", () => {
    ensureAudio();
    endGame();
  });

  closeFromOverlay.addEventListener("click", () => {
    overlay.classList.remove("show");
    setStatus("Score panel closed.");
  });
restartFromOverlay.addEventListener("click", () => {
    // If we are in photoMode, keep overlay shown; otherwise hide it.
    if(!overlay.classList.contains("photoMode")) overlay.classList.remove("show");
    startGame();
  });

  function startGame(){
    ensureAudio();
    lockViewport();
    overlay.classList.remove("show");
    runToken++;
    phase = "idle";
    N = 2;
    maxNThisSession = 2;
    setLevel();
    clearBoard();
    setStatus("Starting…");
    sleep(120).then(async () => { await goldTransition(runToken); await runRound(runToken); });
}

  startBtn.addEventListener("click", () => startGame());

})();
</script>
</body>
</html>
